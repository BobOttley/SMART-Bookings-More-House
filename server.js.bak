require('dotenv').config();
const express = require('express');
const session = require('express-session');
const pgSession = require('connect-pg-simple')(session);
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const nodemailer = require('nodemailer');
const crypto = require('crypto');
const cors = require('cors');
const cron = require('node-cron');

const app = express();
const PORT = process.env.PORT || 3002;

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  }
});

// Test database connection
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('Database connection error:', err);
  } else {
    console.log('Database connected successfully');
  }
});

// Email transporter setup (DEPRECATED - now using DB settings)
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.GMAIL_USER,
    pass: process.env.GMAIL_APP_PASSWORD
  }
});

// Helper function to get email transporter from database settings
async function getEmailTransporter(schoolId = 1) {
  try {
    const result = await pool.query(
      'SELECT smtp_host, smtp_port, smtp_username, smtp_password, smtp_from_email, smtp_from_name, smtp_use_tls FROM booking_settings WHERE school_id = $1',
      [schoolId]
    );

    if (result.rows.length === 0 || !result.rows[0].smtp_host) {
      // Fallback to hardcoded transporter if no settings found
      console.warn('No email settings found in DB, using fallback transporter');
      return transporter;
    }

    const settings = result.rows[0];

    return nodemailer.createTransport({
      host: settings.smtp_host,
      port: settings.smtp_port,
      secure: settings.smtp_port === 465,
      auth: {
        user: settings.smtp_username,
        pass: settings.smtp_password
      },
      tls: {
        rejectUnauthorized: settings.smtp_use_tls
      }
    });
  } catch (error) {
    console.error('Error getting email transporter:', error);
    // Fallback to hardcoded transporter
    return transporter;
  }
}

// Generate iCal calendar invite
function generateCalendarInvite(booking, guide) {
  const now = new Date();
  const tourDate = booking.booking_type === 'open_day' && booking.event_date
    ? new Date(booking.event_date)
    : new Date(booking.scheduled_date);

  const tourTime = booking.booking_type === 'open_day' && booking.start_time
    ? booking.start_time
    : booking.scheduled_time;

  // Parse time and set on date
  const [hours, minutes] = tourTime.split(':');
  tourDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);

  // End time (assume 1 hour tour)
  const endDate = new Date(tourDate);
  endDate.setHours(endDate.getHours() + 1);

  // Format dates for iCal (YYYYMMDDTHHMMSSZ)
  const formatDate = (date) => {
    return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
  };

  const tourType = booking.booking_type === 'open_day' ? 'Open Day Tour' : 'Private Tour';
  const parentName = `${booking.parent_first_name} ${booking.parent_last_name}`;
  const studentInfo = booking.student_first_name
    ? `\nStudent: ${booking.student_first_name} ${booking.student_last_name || ''}`
    : '';

  const description = `Tour Details:\\n` +
    `Type: ${tourType}\\n` +
    `Parent: ${parentName}\\n` +
    `Email: ${booking.email}\\n` +
    `Phone: ${booking.phone || 'Not provided'}${studentInfo}\\n` +
    `Attendees: ${booking.num_attendees}\\n` +
    `Special Requirements: ${booking.special_requirements || 'None'}`;

  const icsContent = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//More House School//Tour Booking//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:REQUEST',
    'BEGIN:VEVENT',
    `UID:booking-${booking.id}@morehouseschool.com`,
    `DTSTAMP:${formatDate(now)}`,
    `DTSTART:${formatDate(tourDate)}`,
    `DTEND:${formatDate(endDate)}`,
    `SUMMARY:${tourType}: ${parentName}`,
    `DESCRIPTION:${description}`,
    `LOCATION:More House School`,
    `ORGANIZER;CN=More House School:MAILTO:booking@morehousemail.org.uk`,
    `ATTENDEE;CN=${guide.name};RSVP=TRUE:MAILTO:${guide.email}`,
    'STATUS:CONFIRMED',
    'SEQUENCE:0',
    'BEGIN:VALARM',
    'TRIGGER:-PT24H',
    'ACTION:DISPLAY',
    'DESCRIPTION:Tour Reminder - Tomorrow',
    'END:VALARM',
    'BEGIN:VALARM',
    'TRIGGER:-PT1H',
    'ACTION:DISPLAY',
    'DESCRIPTION:Tour starts in 1 hour',
    'END:VALARM',
    'END:VEVENT',
    'END:VCALENDAR'
  ].join('\r\n');

  return icsContent;
}

// Send tour guide notification with calendar invite
async function sendTourGuideNotification(booking, guide, notificationType = 'assignment') {
  try {
    const transporter = await getEmailTransporter(booking.school_id || 2);

    const tourDate = booking.booking_type === 'open_day' && booking.event_date
      ? new Date(booking.event_date)
      : new Date(booking.scheduled_date);

    const tourTime = booking.booking_type === 'open_day' && booking.start_time
      ? booking.start_time
      : booking.scheduled_time;

    const formattedDate = tourDate.toLocaleDateString('en-GB', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    const tourType = booking.booking_type === 'open_day' ? 'Open Day Tour' : 'Private Tour';
    const parentName = `${booking.parent_first_name} ${booking.parent_last_name}`;
    const studentInfo = booking.student_first_name
      ? `<li><strong>Student:</strong> ${booking.student_first_name} ${booking.student_last_name || ''}</li>`
      : '';

    let subject, bodyText;

    if (notificationType === 'assignment') {
      subject = `Tour Assignment: ${formattedDate} at ${tourTime}`;
      bodyText = `You have been assigned to conduct a ${tourType.toLowerCase()}.`;
    } else if (notificationType === 'reminder_first') {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tourDateOnly = new Date(tourDate);
      tourDateOnly.setHours(0, 0, 0, 0);
      const reminderDays = Math.ceil((tourDateOnly - today) / (1000 * 60 * 60 * 24));
      subject = `Tour Reminder: ${formattedDate}`;
      bodyText = `This is a reminder about your upcoming ${tourType.toLowerCase()} on ${formattedDate}.`;
    } else if (notificationType === 'reminder_final') {
      subject = `Tour Tomorrow: ${formattedDate} at ${tourTime}`;
      bodyText = `This is your final reminder - you have a ${tourType.toLowerCase()} tomorrow.`;
    }

    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <style>
          body { font-family: 'Inter', Arial, sans-serif; line-height: 1.6; color: #2C3E50; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #091825; color: white; padding: 30px; text-align: center; border-bottom: 3px solid #FF9F1C; }
          .header h1 { margin: 0; font-size: 24px; }
          .content { background: white; padding: 30px; }
          .tour-details { background: #F8FAFC; padding: 20px; border-radius: 8px; margin: 20px 0; }
          .tour-details ul { list-style: none; padding: 0; }
          .tour-details li { padding: 8px 0; border-bottom: 1px solid #E5E7EB; }
          .tour-details li:last-child { border-bottom: none; }
          .button { display: inline-block; background: #FF9F1C; color: #091825; padding: 12px 30px; text-decoration: none; border-radius: 6px; font-weight: 600; margin: 20px 0; }
          .footer { text-align: center; padding: 20px; color: #9CA3AF; font-size: 14px; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>ðŸŽ“ More House School - Tour Guide</h1>
          </div>
          <div class="content">
            <h2>Hello ${guide.name},</h2>
            <p>${bodyText}</p>

            <div class="tour-details">
              <h3>Tour Details</h3>
              <ul>
                <li><strong>Type:</strong> ${tourType}</li>
                <li><strong>Date:</strong> ${formattedDate}</li>
                <li><strong>Time:</strong> ${tourTime}</li>
                <li><strong>Parent:</strong> ${parentName}</li>
                <li><strong>Email:</strong> ${booking.email}</li>
                <li><strong>Phone:</strong> ${booking.phone || 'Not provided'}</li>
                ${studentInfo}
                <li><strong>Attendees:</strong> ${booking.num_attendees}</li>
                <li><strong>Special Requirements:</strong> ${booking.special_requirements || 'None'}</li>
              </ul>
            </div>

            ${notificationType === 'assignment' ? `
              <p><strong>ðŸ“… Calendar Invite Attached</strong></p>
              <p>A calendar invite has been attached to this email. Please accept it to add the tour to your calendar with automatic reminders.</p>
            ` : ''}

            <p>If you have any questions or need to make changes, please contact the school office.</p>

            <p>Thank you,<br>More House School</p>
          </div>
          <div class="footer">
            Powered by <strong style="color: #FF9F1C;">bSMART</strong> ai
          </div>
        </div>
      </body>
      </html>
    `;

    const mailOptions = {
      from: `"More House School" <${transporter.options.auth.user}>`,
      to: guide.email,
      subject: subject,
      html: htmlContent,
      attachments: notificationType === 'assignment' ? [{
        filename: 'tour-invite.ics',
        content: generateCalendarInvite(booking, guide),
        contentType: 'text/calendar'
      }] : []
    };

    console.log(`ðŸ“§ Sending ${notificationType} notification to tour guide: ${guide.email}`);
    await transporter.sendMail(mailOptions);
    console.log(`âœ… Tour guide notification sent successfully`);

    return true;
  } catch (error) {
    console.error(`âŒ Error sending tour guide notification:`, error);
    return false;
  }
}

// Middleware
app.use(cors({
  origin: true,
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Disable caching for all static files
app.use(express.static('public', {
  setHeaders: (res, path) => {
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
  }
}));

// Session configuration
app.use(session({
  store: new pgSession({
    pool: pool,
    tableName: 'session'
  }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    httpOnly: true,
    secure: false // Set to true if using HTTPS
  }
}));

// Authentication middleware
const requireAuth = (req, res, next) => {
  if (req.session && req.session.userId) {
    next();
  } else {
    res.status(401).json({ success: false, error: 'Authentication required' });
  }
};

const requireAdmin = async (req, res, next) => {
  if (!req.session || !req.session.userId) {
    return res.status(401).json({ success: false, error: 'Authentication required' });
  }

  try {
    const result = await pool.query(
      'SELECT role FROM admin_users WHERE id = $1',
      [req.session.userId]
    );

    if (result.rows.length === 0 || (result.rows[0].role !== 'admin' && result.rows[0].role !== 'super_admin')) {
      return res.status(403).json({ success: false, error: 'Admin access required' });
    }

    next();
  } catch (error) {
    console.error('Admin check error:', error);
    res.status(500).json({ success: false, error: 'Server error' });
  }
};

// ==================== BOOKING SETTINGS ENDPOINTS ====================

// Get booking settings for a school
app.get('/api/booking-settings/:schoolId', async (req, res) => {
  try {
    const { schoolId } = req.params;

    const result = await pool.query(
      'SELECT * FROM booking_settings WHERE school_id = $1',
      [schoolId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Settings not found' });
    }

    res.json({ success: true, settings: result.rows[0] });
  } catch (error) {
    console.error('Get settings error:', error);
    res.status(500).json({ success: false, error: 'Failed to get settings' });
  }
});

// Update booking settings
app.put('/api/booking-settings/:schoolId', async (req, res) => {
  try {
    const { schoolId } = req.params;
    const {
      tour_duration_options,
      default_tour_duration,
      booking_window_days,
      cancellation_window_hours,
      max_concurrent_tours,
      requires_approval,
      allow_waitlist,
      available_days,
      tour_start_time,
      tour_end_time,
      private_tour_enabled,
      private_tour_duration_minutes,
      private_tour_min_notice_days,
      private_tour_max_advance_days,
      private_tour_max_attendees,
      private_tour_buffer_minutes,
      private_tour_start_time,
      private_tour_end_time,
      has_prospectus_app,
      prospectus_url,
      school_name,
      logo_url,
      logo_size,
      form_heading,
      form_subtitle,
      primary_colour,
      secondary_colour
    } = req.body;

    const result = await pool.query(
      `UPDATE booking_settings SET
        tour_duration_options = $1,
        default_tour_duration = $2,
        booking_window_days = $3,
        cancellation_window_hours = $4,
        max_concurrent_tours = $5,
        requires_approval = $6,
        allow_waitlist = $7,
        available_days = $8,
        tour_start_time = $9,
        tour_end_time = $10,
        private_tour_enabled = $11,
        private_tour_duration_minutes = $12,
        private_tour_min_notice_days = $13,
        private_tour_max_advance_days = $14,
        private_tour_max_attendees = $15,
        private_tour_buffer_minutes = $16,
        private_tour_start_time = $17,
        private_tour_end_time = $18,
        has_prospectus_app = $19,
        prospectus_url = $20,
        school_name = $21,
        logo_url = $22,
        logo_size = $23,
        form_heading = $24,
        form_subtitle = $25,
        primary_colour = $26,
        secondary_colour = $27,
        updated_at = NOW()
      WHERE school_id = $28
      RETURNING *`,
      [
        tour_duration_options,
        default_tour_duration,
        booking_window_days,
        cancellation_window_hours,
        max_concurrent_tours,
        requires_approval,
        allow_waitlist,
        available_days,
        tour_start_time,
        tour_end_time,
        private_tour_enabled,
        private_tour_duration_minutes,
        private_tour_min_notice_days,
        private_tour_max_advance_days,
        private_tour_max_attendees,
        private_tour_buffer_minutes,
        private_tour_start_time,
        private_tour_end_time,
        has_prospectus_app,
        prospectus_url,
        school_name,
        logo_url,
        logo_size,
        form_heading,
        form_subtitle,
        primary_colour,
        secondary_colour,
        schoolId
      ]
    );

    res.json({ success: true, settings: result.rows[0] });
  } catch (error) {
    console.error('Update settings error:', error);
    res.status(500).json({ success: false, error: 'Failed to update settings' });
  }
});

// ==================== EMAIL SETTINGS ENDPOINTS ====================

// Get email settings
app.get('/api/email-settings/:schoolId', async (req, res) => {
  try {
    const { schoolId } = req.params;

    const result = await pool.query(
      'SELECT smtp_host, smtp_port, smtp_username, smtp_password, smtp_from_email, smtp_from_name, smtp_use_tls, reminder_days_before_1, reminder_days_before_2, followup_days_after, guide_reminder_days_before_1, guide_reminder_days_before_2 FROM booking_settings WHERE school_id = $1',
      [schoolId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Settings not found' });
    }

    res.json({ success: true, settings: result.rows[0] });
  } catch (error) {
    console.error('Get email settings error:', error);
    res.status(500).json({ success: false, error: 'Failed to get email settings' });
  }
});

// Update email settings
app.put('/api/email-settings/:schoolId', async (req, res) => {
  try {
    const { schoolId } = req.params;
    const { smtp_host, smtp_port, smtp_username, smtp_password, smtp_from_email, smtp_from_name, smtp_use_tls, reminder_days_before_1, reminder_days_before_2, followup_days_after, guide_reminder_days_before_1, guide_reminder_days_before_2 } = req.body;

    const result = await pool.query(
      `UPDATE booking_settings
       SET smtp_host = $1, smtp_port = $2, smtp_username = $3, smtp_password = $4,
           smtp_from_email = $5, smtp_from_name = $6, smtp_use_tls = $7,
           reminder_days_before_1 = $8, reminder_days_before_2 = $9, followup_days_after = $10,
           guide_reminder_days_before_1 = $11, guide_reminder_days_before_2 = $12,
           updated_at = NOW()
       WHERE school_id = $13
       RETURNING *`,
      [smtp_host, smtp_port, smtp_username, smtp_password, smtp_from_email, smtp_from_name, smtp_use_tls, reminder_days_before_1, reminder_days_before_2, followup_days_after, guide_reminder_days_before_1, guide_reminder_days_before_2, schoolId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Settings not found' });
    }

    res.json({ success: true, settings: result.rows[0] });
  } catch (error) {
    console.error('Update email settings error:', error);
    res.status(500).json({ success: false, error: 'Failed to update email settings' });
  }
});

// Test email settings
app.post('/api/email-settings/test', async (req, res) => {
  try {
    const { smtp_host, smtp_port, smtp_username, smtp_password, smtp_from_email, smtp_from_name, smtp_use_tls, test_email } = req.body;

    console.log('ðŸ“§ Test email request received:', {
      smtp_host,
      smtp_port,
      smtp_username,
      smtp_from_email,
      test_email,
      smtp_use_tls
    });

    // Create a test transporter
    const testTransporter = nodemailer.createTransport({
      host: smtp_host,
      port: smtp_port,
      secure: smtp_port === 465, // true for 465, false for other ports
      auth: {
        user: smtp_username,
        pass: smtp_password
      },
      tls: {
        rejectUnauthorized: smtp_use_tls
      },
      connectionTimeout: 10000, // 10 seconds timeout
      greetingTimeout: 10000
    });

    console.log('ðŸ“§ Verifying SMTP connection...');

    // Verify connection before sending
    await testTransporter.verify();
    console.log('âœ… SMTP connection verified!');

    // Send test email
    await testTransporter.sendMail({
      from: `"${smtp_from_name}" <${smtp_from_email}>`,
      to: test_email,
      subject: 'Test Email from SMART Booking System',
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #091825;">Test Email Successful!</h2>
          <p>Your email settings are configured correctly.</p>
          <p><strong>Configuration:</strong></p>
          <ul>
            <li>SMTP Host: ${smtp_host}</li>
            <li>SMTP Port: ${smtp_port}</li>
            <li>Username: ${smtp_username}</li>
            <li>From: ${smtp_from_name} &lt;${smtp_from_email}&gt;</li>
            <li>TLS: ${smtp_use_tls ? 'Enabled' : 'Disabled'}</li>
          </ul>
          <p style="color: #6B7280; font-size: 0.875rem; margin-top: 2rem;">
            Powered by <span style="color: #FF9F1C; font-weight: 600;">bSMART</span> ai
          </p>
        </div>
      `
    });

    res.json({ success: true, message: 'Test email sent successfully' });
  } catch (error) {
    console.error('Test email error:', error);
    res.status(500).json({ success: false, error: error.message || 'Failed to send test email' });
  }
});

// ==================== EVENTS ENDPOINTS ====================

// Get all events for a school
app.get('/api/events', async (req, res) => {
  try {
    const { schoolId, eventType, status, startDate, endDate } = req.query;

    let query = 'SELECT * FROM events WHERE school_id = $1';
    const params = [schoolId];
    let paramCount = 1;

    if (eventType) {
      paramCount++;
      query += ` AND event_type = $${paramCount}`;
      params.push(eventType);
    }

    if (status) {
      paramCount++;
      query += ` AND status = $${paramCount}`;
      params.push(status);
    }

    if (startDate) {
      paramCount++;
      query += ` AND event_date >= $${paramCount}`;
      params.push(startDate);
    }

    if (endDate) {
      paramCount++;
      query += ` AND event_date <= $${paramCount}`;
      params.push(endDate);
    }

    query += ' ORDER BY event_date ASC, start_time ASC';

    const result = await pool.query(query, params);
    res.json({ success: true, events: result.rows });
  } catch (error) {
    console.error('Get events error:', error);
    res.status(500).json({ success: false, error: 'Failed to get events' });
  }
});

// Get single event
app.get('/api/events/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      'SELECT * FROM events WHERE id = $1',
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Event not found' });
    }

    res.json({ success: true, event: result.rows[0] });
  } catch (error) {
    console.error('Get event error:', error);
    res.status(500).json({ success: false, error: 'Failed to get event' });
  }
});

// Create new event (No auth for now - accessed via iframe from authenticated admin dashboard)
app.post('/api/events', async (req, res) => {
  try {
    const {
      school_id,
      event_type,
      title,
      description,
      event_date,
      start_time,
      end_time,
      location,
      max_capacity
    } = req.body;

    const result = await pool.query(
      `INSERT INTO events (
        school_id, event_type, title, description, event_date,
        start_time, end_time, location, max_capacity, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *`,
      [
        school_id,
        event_type,
        title,
        description,
        event_date,
        start_time,
        end_time,
        location,
        max_capacity,
        req.session.userId
      ]
    );

    res.json({ success: true, event: result.rows[0] });
  } catch (error) {
    console.error('Create event error:', error);
    res.status(500).json({ success: false, error: 'Failed to create event' });
  }
});

// Update event
app.put('/api/events/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const {
      event_type,
      title,
      description,
      event_date,
      start_time,
      end_time,
      location,
      max_capacity,
      status
    } = req.body;

    // Validate required fields
    if (!title || !event_date || !start_time || !end_time) {
      return res.status(400).json({
        success: false,
        error: 'Required fields missing: title, event_date, start_time, end_time'
      });
    }

    const result = await pool.query(
      `UPDATE events SET
        event_type = $1,
        title = $2,
        description = $3,
        event_date = $4,
        start_time = $5,
        end_time = $6,
        location = $7,
        max_capacity = $8,
        status = $9,
        updated_at = NOW()
      WHERE id = $10
      RETURNING *`,
      [event_type, title, description, event_date, start_time, end_time, location, max_capacity, status, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Event not found' });
    }

    res.json({ success: true, event: result.rows[0] });
  } catch (error) {
    console.error('Update event error:', error);
    res.status(500).json({ success: false, error: 'Failed to update event' });
  }
});

// Delete event
app.delete('/api/events/:id', async (req, res) => {
  try {
    const { id } = req.params;

    await pool.query('DELETE FROM events WHERE id = $1', [id]);
    res.json({ success: true, message: 'Event deleted successfully' });
  } catch (error) {
    console.error('Delete event error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete event' });
  }
});

// ==================== INQUIRY ENDPOINTS ====================

// Get inquiry by ID (for pre-populating booking form)
app.get('/api/inquiry/:inquiryId', async (req, res) => {
  try {
    const { inquiryId } = req.params;

    const result = await pool.query(
      `SELECT
        id,
        parent_email,
        parent_name,
        contact_number,
        first_name,
        family_surname,
        age_group,
        entry_year,
        created_at
      FROM inquiries
      WHERE id = $1 AND deleted_at IS NULL
      LIMIT 1`,
      [inquiryId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Inquiry not found' });
    }

    res.json({
      success: true,
      inquiry: result.rows[0]
    });
  } catch (error) {
    console.error('Get inquiry error:', error);
    res.status(500).json({ success: false, error: 'Failed to get inquiry' });
  }
});

// ==================== PARENT VERIFICATION ENDPOINTS ====================

// Check if parent exists in enquiry database
app.post('/api/verify-parent', async (req, res) => {
  try {
    const { name, email, phone } = req.body;

    if (!name || !email || !phone) {
      return res.status(400).json({ error: 'Name, email and phone number are required' });
    }

    let query = `
      SELECT
        id as inquiry_id,
        parent_email,
        parent_name,
        contact_number,
        first_name,
        family_surname,
        age_group,
        entry_year,
        created_at
      FROM inquiries
      WHERE deleted_at IS NULL
    `;
    const params = [];
    let paramCount = 0;

    // Check name (case-insensitive partial match)
    if (name) {
      paramCount++;
      query += ` AND LOWER(parent_name) LIKE LOWER($${paramCount})`;
      params.push(`%${name}%`);
    }

    // Check email
    if (email) {
      paramCount++;
      query += ` AND LOWER(parent_email) = LOWER($${paramCount})`;
      params.push(email);
    }

    // Check phone
    if (phone) {
      paramCount++;
      query += ` AND contact_number LIKE $${paramCount}`;
      params.push(`%${phone}%`);
    }

    query += ` ORDER BY created_at DESC LIMIT 1`;

    const result = await pool.query(query, params);

    if (result.rows.length > 0) {
      res.json({
        found: true,
        parent: {
          email: result.rows[0].parent_email,
          name: result.rows[0].parent_name,
          inquiry_id: result.rows[0].inquiry_id,
          contact_number: result.rows[0].contact_number,
          first_name: result.rows[0].first_name,
          family_surname: result.rows[0].family_surname,
          age_group: result.rows[0].age_group,
          entry_year: result.rows[0].entry_year,
          registered_at: result.rows[0].created_at
        }
      });
    } else {
      res.json({ found: false });
    }
  } catch (error) {
    console.error('Parent verification error:', error);
    res.status(500).json({ error: 'Failed to verify parent information' });
  }
});

// ==================== BOOKINGS ENDPOINTS ====================

// Get all bookings
app.get('/api/bookings', async (req, res) => {
  try {
    const { schoolId, eventId, status, startDate, endDate } = req.query;

    let query = `
      SELECT DISTINCT ON (b.id) b.*, e.title as event_title, e.event_date, e.start_time,
             tg.name as guide_name,
             i.entry_year, i.sciences, i.mathematics, i.english, i.languages, i.humanities,
             i.business, i.drama, i.music, i.art, i.creative_writing, i.sport,
             i.leadership, i.community_service, i.outdoor_education, i.academic_excellence,
             i.pastoral_care, i.university_preparation, i.personal_development,
             i.career_guidance, i.extracurricular_opportunities
      FROM bookings b
      LEFT JOIN events e ON b.event_id = e.id
      LEFT JOIN tour_guides tg ON b.assigned_guide_id = tg.id
      LEFT JOIN inquiries i ON (b.inquiry_id = i.id OR (b.email = i.parent_email AND i.first_name = b.student_first_name))
      WHERE b.school_id = $1
    `;
    const params = [schoolId];
    let paramCount = 1;

    if (eventId) {
      paramCount++;
      query += ` AND b.event_id = $${paramCount}`;
      params.push(eventId);
    }

    if (status) {
      paramCount++;
      query += ` AND b.status = $${paramCount}`;
      params.push(status);
    }

    if (startDate) {
      paramCount++;
      query += ` AND e.event_date >= $${paramCount}`;
      params.push(startDate);
    }

    if (endDate) {
      paramCount++;
      query += ` AND e.event_date <= $${paramCount}`;
      params.push(endDate);
    }

    query += ' ORDER BY b.id, b.booked_at DESC';

    const result = await pool.query(query, params);
    res.json({ success: true, bookings: result.rows });
  } catch (error) {
    console.error('Get bookings error:', error);
    res.status(500).json({ success: false, error: 'Failed to get bookings' });
  }
});

// Get single booking
app.get('/api/bookings/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      `SELECT b.*, e.title as event_title, e.event_date, e.start_time, e.end_time,
              tg.name as guide_name
       FROM bookings b
       LEFT JOIN events e ON b.event_id = e.id
       LEFT JOIN tour_guides tg ON b.assigned_guide_id = tg.id
       WHERE b.id = $1`,
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    res.json({ success: true, booking: result.rows[0] });
  } catch (error) {
    console.error('Get booking error:', error);
    res.status(500).json({ success: false, error: 'Failed to get booking' });
  }
});

// Create new booking (Public endpoint)
app.post('/api/bookings', async (req, res) => {
  try {
    const {
      school_id,
      event_id,
      inquiry_id,
      parent_first_name,
      parent_last_name,
      email,
      phone,
      student_first_name,
      student_last_name,
      student_age,
      student_year_group,
      num_attendees,
      special_requirements,
      preferred_language,
      booking_type
    } = req.body;

    // Cross-check parent details against inquiries database
    let matchedInquiry = null;
    const parentFullName = `${parent_first_name} ${parent_last_name}`.trim();

    if (email && phone && parentFullName) {
      try {
        let inquiryQuery = `
          SELECT id, parent_email, parent_name, contact_number, first_name, family_surname
          FROM inquiries
          WHERE deleted_at IS NULL
        `;
        const inquiryParams = [];
        let paramCount = 0;

        // Check parent name (partial match)
        paramCount++;
        inquiryQuery += ` AND LOWER(parent_name) LIKE LOWER($${paramCount})`;
        inquiryParams.push(`%${parentFullName}%`);

        // Check email
        paramCount++;
        inquiryQuery += ` AND LOWER(parent_email) = LOWER($${paramCount})`;
        inquiryParams.push(email);

        // Check phone
        paramCount++;
        inquiryQuery += ` AND contact_number LIKE $${paramCount}`;
        inquiryParams.push(`%${phone}%`);

        inquiryQuery += ` ORDER BY created_at DESC LIMIT 1`;

        const inquiryResult = await pool.query(inquiryQuery, inquiryParams);

        if (inquiryResult.rows.length > 0) {
          matchedInquiry = inquiryResult.rows[0];
          console.log('Matched inquiry found:', matchedInquiry.id, 'for booking by', parentFullName, email);
        } else {
          console.log('No matching inquiry found for', parentFullName, email, phone);
        }
      } catch (error) {
        console.error('Error checking inquiries:', error);
        // Continue with booking even if inquiry check fails
      }
    }

    // Get booking settings
    const settingsResult = await pool.query(
      'SELECT * FROM booking_settings WHERE school_id = $1',
      [school_id]
    );
    const settings = settingsResult.rows[0];

    // For private tours, event_id is optional
    let event = null;
    let initialStatus = settings.requires_approval ? 'pending' : 'confirmed';

    if (booking_type === 'private_tour') {
      // Private tours always start as pending (admin must schedule them)
      initialStatus = 'pending';
    } else {
      // Get event details for open day bookings
      if (!event_id) {
        return res.status(400).json({ success: false, error: 'Event ID is required for open day bookings' });
      }

      const eventResult = await pool.query(
        'SELECT * FROM events WHERE id = $1 AND school_id = $2',
        [event_id, school_id]
      );

      if (eventResult.rows.length === 0) {
        return res.status(404).json({ success: false, error: 'Event not found' });
      }

      event = eventResult.rows[0];

      // Check capacity
      if (event.current_bookings + num_attendees > event.max_capacity) {
        return res.status(400).json({ success: false, error: 'Event is fully booked' });
      }

      // Determine initial status based on settings
      initialStatus = settings.requires_approval ? 'pending' : 'confirmed';
    }

    // Generate cancellation token and feedback token
    const cancellationToken = crypto.randomBytes(32).toString('hex');
    const feedbackToken = crypto.randomBytes(32).toString('hex');

    // Use matched inquiry ID if found, otherwise use the one provided
    const finalInquiryId = matchedInquiry ? matchedInquiry.id : inquiry_id;

    // Create booking
    const bookingResult = await pool.query(
      `INSERT INTO bookings (
        school_id, event_id, inquiry_id, parent_first_name, parent_last_name,
        email, phone, student_first_name, student_last_name, student_age,
        student_year_group, num_attendees, special_requirements, preferred_language,
        booking_type, status, cancellation_token, feedback_token
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
      RETURNING *`,
      [
        school_id, event_id, finalInquiryId, parent_first_name, parent_last_name,
        email, phone, student_first_name, student_last_name, student_age,
        student_year_group, num_attendees, special_requirements, preferred_language,
        booking_type, initialStatus, cancellationToken, feedbackToken
      ]
    );

    const booking = bookingResult.rows[0];

    // Update event booking count (only for open day bookings)
    if (booking_type !== 'private_tour' && event_id) {
      await pool.query(
        'UPDATE events SET current_bookings = current_bookings + $1 WHERE id = $2',
        [num_attendees, event_id]
      );
    }

    // Update inquiry record to mark that they've booked
    if (finalInquiryId) {
      try {
        if (booking_type === 'open_day') {
          await pool.query(
            'UPDATE inquiries SET open_day_booked = true, open_day_booked_at = NOW() WHERE id = $1',
            [finalInquiryId]
          );
          console.log(`Marked inquiry ${finalInquiryId} as having booked an open day`);
        } else if (booking_type === 'private_tour') {
          await pool.query(
            'UPDATE inquiries SET tour_booked = true, tour_booked_at = NOW() WHERE id = $1',
            [finalInquiryId]
          );
          console.log(`Marked inquiry ${finalInquiryId} as having booked a private tour`);
        }
      } catch (error) {
        console.error('Error updating inquiry booking status:', error);
        // Don't fail the booking if inquiry update fails
      }
    }

    // Send confirmation email
    try {
      const eventTitle = event ? event.title : 'Private Tour Request';

      // Build email content based on booking type
      let emailText, emailHTML;

      if (booking_type === 'private_tour') {
        emailText = `Dear ${parent_first_name} ${parent_last_name},

Thank you for your private tour request.

Your request has been received and is currently pending review. Our admissions team will review your preferred date and time, and will contact you shortly to confirm the tour schedule.

Request Details:
- Type: Private Tour
- Number of Attendees: ${num_attendees}
${student_first_name ? `- Student: ${student_first_name} ${student_last_name}\n` : ''}
${special_requirements ? `- Your Preferences:\n${special_requirements}\n` : ''}

If you need to make changes or have questions, please reply to this email.

Best regards,
More House School Admissions Team`;

        emailHTML = `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #091825;">Thank you for your private tour request</h2>
            <p>Dear ${parent_first_name} ${parent_last_name},</p>
            <p>Your request has been <strong>received</strong> and is currently pending review. Our admissions team will review your preferred date and time, and will contact you shortly to confirm the tour schedule.</p>

            <h3 style="color: #091825;">Request Details</h3>
            <table style="width: 100%; border-collapse: collapse;">
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Type:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">Private Tour</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Attendees:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${num_attendees}</td></tr>
              ${student_first_name ? `<tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Student:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${student_first_name} ${student_last_name}</td></tr>` : ''}
            </table>
            ${special_requirements ? `<div style="margin-top: 20px;"><strong>Your Preferences:</strong><p style="white-space: pre-line;">${special_requirements}</p></div>` : ''}

            <p style="margin-top: 20px;">If you need to make changes or have questions, please reply to this email.</p>

            <p style="margin-top: 30px; color: #666; font-size: 14px;">
              Best regards,<br>
              More House School<br>
              Admissions Team
            </p>
          </div>
        `;
      } else {
        emailText = `Dear ${parent_first_name} ${parent_last_name},

Thank you for booking ${event.title}.

Your booking has been ${initialStatus === 'confirmed' ? 'confirmed' : 'received and is pending approval'}.

Booking Details:
- Event: ${event.title}
- Date: ${event.event_date}
- Time: ${event.start_time} - ${event.end_time}
- Location: ${event.location || 'TBC'}
- Number of Attendees: ${num_attendees}
${student_first_name ? `- Student: ${student_first_name} ${student_last_name}\n` : ''}

If you need to cancel or reschedule, please reply to this email.

Best regards,
More House School Admissions Team`;

        emailHTML = `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #091825;">Thank you for your booking</h2>
            <p>Dear ${parent_first_name} ${parent_last_name},</p>
            <p>Your booking for <strong>${event.title}</strong> has been ${initialStatus === 'confirmed' ? 'confirmed' : 'received and is pending approval'}.</p>

            <h3 style="color: #091825;">Booking Details</h3>
            <table style="width: 100%; border-collapse: collapse;">
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Event:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${event.title}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Date:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${event.event_date}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Time:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${event.start_time} - ${event.end_time}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Location:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${event.location || 'TBC'}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Attendees:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${num_attendees}</td></tr>
              ${student_first_name ? `<tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Student:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${student_first_name} ${student_last_name}</td></tr>` : ''}
            </table>

            <p style="margin-top: 20px;">If you need to cancel or reschedule your booking, please reply to this email.</p>

            <p style="margin-top: 30px; color: #666; font-size: 14px;">
              Best regards,<br>
              More House School<br>
              Admissions Team
            </p>
          </div>
        `;
      }

      const mailOptions = {
        from: process.env.EMAIL_FROM,
        to: email,
        replyTo: process.env.GMAIL_USER,
        subject: `More House School - ${eventTitle} Confirmation`,
        text: emailText,
        html: emailHTML
      };

      await (await getEmailTransporter()).sendMail(mailOptions);

      // Log email
      await pool.query(
        `INSERT INTO booking_email_logs (booking_id, email_type, recipient, subject, sent_at)
         VALUES ($1, $2, $3, $4, NOW())`,
        [booking.id, 'confirmation', email, mailOptions.subject]
      );
    } catch (emailError) {
      console.error('Email send error:', emailError);
      // Don't fail the booking if email fails
    }

    res.json({ success: true, booking, status: initialStatus });
  } catch (error) {
    console.error('Create booking error:', error);
    res.status(500).json({ success: false, error: 'Failed to create booking' });
  }
});

// Update booking details
app.put('/api/bookings/:id', async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`[UPDATE BOOKING] Received request to update booking #${id}`);
    console.log('[UPDATE BOOKING] Request body:', req.body);

    const {
      parent_first_name,
      parent_last_name,
      email,
      phone,
      student_first_name,
      student_last_name,
      student_age,
      student_year_group,
      num_attendees,
      special_requirements,
      preferred_language
    } = req.body;

    // Validate required fields
    if (!parent_first_name || !parent_last_name || !email || !phone || !student_first_name || !num_attendees) {
      console.log('[UPDATE BOOKING] Validation failed - missing required fields');
      return res.status(400).json({ success: false, error: 'Required fields are missing' });
    }

    // Update the booking
    const result = await pool.query(
      `UPDATE bookings SET
        parent_first_name = $1,
        parent_last_name = $2,
        email = $3,
        phone = $4,
        student_first_name = $5,
        student_last_name = $6,
        student_age = $7,
        student_year_group = $8,
        num_attendees = $9,
        special_requirements = $10,
        preferred_language = $11,
        updated_at = NOW()
      WHERE id = $12
      RETURNING *`,
      [
        parent_first_name,
        parent_last_name,
        email,
        phone,
        student_first_name,
        student_last_name,
        student_age,
        student_year_group,
        num_attendees,
        special_requirements,
        preferred_language,
        id
      ]
    );

    if (result.rows.length === 0) {
      console.log('[UPDATE BOOKING] Booking not found');
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    console.log('[UPDATE BOOKING] Successfully updated booking');
    res.json({ success: true, booking: result.rows[0] });
  } catch (error) {
    console.error('[UPDATE BOOKING] Error:', error);
    res.status(500).json({ success: false, error: 'Failed to update booking' });
  }
});

// Mark booking as no-show
app.put('/api/bookings/:id/no-show', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      `UPDATE bookings SET
        no_show_at = NOW(),
        updated_at = NOW()
      WHERE id = $1
      RETURNING *`,
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    res.json({ success: true, booking: result.rows[0] });
  } catch (error) {
    console.error('Mark as no-show error:', error);
    res.status(500).json({ success: false, error: 'Failed to mark as no-show' });
  }
});

// Update booking status
app.put('/api/bookings/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status, assigned_guide_id } = req.body;

    const result = await pool.query(
      `UPDATE bookings SET
        status = $1,
        assigned_guide_id = $2,
        updated_at = NOW()
      WHERE id = $3
      RETURNING *`,
      [status, assigned_guide_id || null, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    const booking = result.rows[0];

    // Send status update email
    try {
      let emailSubject = '';
      let emailBody = '';

      if (status === 'confirmed') {
        emailSubject = 'Booking Confirmed';
        emailBody = '<p>Great news! Your booking has been confirmed.</p>';
      } else if (status === 'cancelled') {
        emailSubject = 'Booking Cancelled';
        emailBody = '<p>Your booking has been cancelled.</p>';
      }

      const mailOptions = {
        from: process.env.EMAIL_FROM,
        to: booking.email,
        subject: emailSubject,
        html: `
          <h2>${emailSubject}</h2>
          <p>Dear ${booking.parent_first_name} ${booking.parent_last_name},</p>
          ${emailBody}
          <p>Booking Reference: #${booking.id}</p>
        `
      };

      await (await getEmailTransporter()).sendMail(mailOptions);

      await pool.query(
        `INSERT INTO booking_email_logs (booking_id, email_type, recipient, subject, sent_at)
         VALUES ($1, $2, $3, $4, NOW())`,
        [booking.id, 'status_update', booking.email, mailOptions.subject]
      );
    } catch (emailError) {
      console.error('Email send error:', emailError);
    }

    res.json({ success: true, booking });
  } catch (error) {
    console.error('Update booking status error:', error);
    res.status(500).json({ success: false, error: 'Failed to update booking status' });
  }
});

// Check-in booking
app.post('/api/bookings/:id/checkin', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      `UPDATE bookings SET
        checked_in_at = NOW(),
        checked_in_by = $1,
        updated_at = NOW()
      WHERE id = $2
      RETURNING *`,
      [req.session.userId, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    res.json({ success: true, booking: result.rows[0] });
  } catch (error) {
    console.error('Check-in error:', error);
    res.status(500).json({ success: false, error: 'Failed to check in' });
  }
});

// Assign tour guide to open day booking
app.post('/api/bookings/:id/assign-guide', async (req, res) => {
  try {
    const { id } = req.params;
    const { guideId } = req.body;

    if (!guideId) {
      return res.status(400).json({ success: false, error: 'Guide ID is required' });
    }

    // Get guide details with email
    const guideResult = await pool.query('SELECT id, name, email FROM tour_guides WHERE id = $1', [guideId]);

    if (guideResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Tour guide not found' });
    }

    const guide = guideResult.rows[0];

    // Update the booking with the assigned guide
    const result = await pool.query(
      `UPDATE bookings SET
        assigned_guide_id = $1,
        updated_at = NOW()
      WHERE id = $2
      RETURNING *`,
      [guideId, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    const booking = result.rows[0];

    // Send assignment notification with calendar invite
    console.log(`ðŸ“§ Sending assignment notification to tour guide: ${guide.name}`);
    await sendTourGuideNotification(booking, guide, 'assignment');

    res.json({ success: true, booking: booking });
  } catch (error) {
    console.error('Assign guide error:', error);
    res.status(500).json({ success: false, error: 'Failed to assign guide' });
  }
});

// Schedule/Accept booking (Admin endpoint)
app.post('/api/bookings/:id/schedule', async (req, res) => {
  try {
    const { id } = req.params;
    const { scheduled_date, scheduled_time, assigned_guide_id } = req.body;

    // Generate response token for parent interactions
    const responseToken = crypto.randomBytes(32).toString('hex');

    const result = await pool.query(
      `UPDATE bookings SET
        status = 'confirmed',
        scheduled_date = $1,
        scheduled_time = $2,
        assigned_guide_id = $3,
        response_token = $4,
        updated_at = NOW()
      WHERE id = $5
      RETURNING *`,
      [scheduled_date, scheduled_time, assigned_guide_id, responseToken, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    const booking = result.rows[0];

    // Get tour guide details if assigned
    let guide = null;
    if (assigned_guide_id) {
      const guideResult = await pool.query(
        'SELECT * FROM tour_guides WHERE id = $1',
        [assigned_guide_id]
      );
      guide = guideResult.rows[0];
    }

    // Send confirmation email
    try {
      const scheduledDateTime = `${new Date(scheduled_date).toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })} at ${scheduled_time}`;

      const mailOptions = {
        from: process.env.EMAIL_FROM,
        to: booking.email,
        replyTo: process.env.GMAIL_USER,
        subject: `More House School - Tour Confirmed for ${scheduledDateTime}`,
        text: `Dear ${booking.parent_first_name} ${booking.parent_last_name},

Great news! Your private tour request has been scheduled.

Tour Details:
- Date & Time: ${scheduledDateTime}
- Location: More House School
- Number of Attendees: ${booking.num_attendees}
${booking.student_first_name ? `- Student: ${booking.student_first_name} ${booking.student_last_name}\n` : ''}
${guide ? `- Your Tour Guide: ${guide.name}\n` : ''}

We look forward to welcoming you to More House School!

If you need to reschedule or have any questions, please reply to this email.

Best regards,
More House School Admissions Team`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #091825;">Tour Confirmed!</h2>
            <p>Dear ${booking.parent_first_name} ${booking.parent_last_name},</p>
            <p>Great news! Your private tour request has been <strong>confirmed and scheduled</strong>.</p>

            <h3 style="color: #091825;">Tour Details</h3>
            <table style="width: 100%; border-collapse: collapse;">
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Date & Time:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${scheduledDateTime}</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Location:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">More House School</td></tr>
              <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Attendees:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${booking.num_attendees}</td></tr>
              ${booking.student_first_name ? `<tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Student:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${booking.student_first_name} ${booking.student_last_name}</td></tr>` : ''}
              ${guide ? `<tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Tour Guide:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">${guide.name}</td></tr>` : ''}
            </table>

            <p style="margin-top: 20px;">We look forward to welcoming you to More House School!</p>
            <p style="margin-top: 10px;">If you need to reschedule or have any questions, please reply to this email.</p>

            <p style="margin-top: 30px; color: #666; font-size: 14px;">
              Best regards,<br>
              More House School<br>
              Admissions Team
            </p>
          </div>
        `
      };

      await (await getEmailTransporter()).sendMail(mailOptions);

      // Log email
      await pool.query(
        `INSERT INTO booking_email_logs (booking_id, email_type, recipient, subject, sent_at)
         VALUES ($1, $2, $3, $4, NOW())`,
        [booking.id, 'tour_scheduled', booking.email, mailOptions.subject]
      );
    } catch (emailError) {
      console.error('Email send error:', emailError);
    }

    // Send notification to tour guide if assigned
    if (guide) {
      console.log(`ðŸ“§ Sending assignment notification to tour guide: ${guide.name}`);
      await sendTourGuideNotification(booking, guide, 'assignment');
    }

    res.json({ success: true, booking, guide });
  } catch (error) {
    console.error('Schedule booking error:', error);
    res.status(500).json({ success: false, error: 'Failed to schedule booking' });
  }
});

// Decline booking with alternatives (Admin endpoint)
app.post('/api/bookings/:id/decline', async (req, res) => {
  try {
    const { id } = req.params;
    const { decline_reason, alternative_dates } = req.body;

    // Generate response token for parent interactions
    const responseToken = crypto.randomBytes(32).toString('hex');

    const result = await pool.query(
      `UPDATE bookings SET
        status = 'declined',
        decline_reason = $1,
        alternative_dates = $2,
        response_token = $3,
        updated_at = NOW()
      WHERE id = $4
      RETURNING *`,
      [decline_reason, JSON.stringify(alternative_dates || []), responseToken, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    const booking = result.rows[0];

    // Send decline email with alternatives
    try {
      const hasAlternatives = alternative_dates && alternative_dates.length > 0;

      let alternativesText = '';
      let alternativesHTML = '';

      if (hasAlternatives) {
        alternativesText = '\n\nAlternative dates available:\n' +
          alternative_dates.map((alt, idx) => `${idx + 1}. ${alt.date} at ${alt.time}`).join('\n') +
          `\n\nTo accept one of these alternatives, please visit:\nhttp://localhost:3002/respond.html?token=${responseToken}`;

        alternativesHTML = `
          <h3 style="color: #091825; margin-top: 20px;">Alternative Dates Available</h3>
          <ul style="list-style: none; padding: 0;">
            ${alternative_dates.map(alt => `
              <li style="padding: 10px; margin: 5px 0; background: #f8f9fa; border-left: 3px solid var(--award-gold);">
                <strong>${alt.date}</strong> at ${alt.time}
              </li>
            `).join('')}
          </ul>
          <p style="margin-top: 20px;">
            <a href="http://localhost:3002/respond.html?token=${responseToken}"
               style="display: inline-block; padding: 12px 24px; background: #FF9F1C; color: white; text-decoration: none; border-radius: 4px; font-weight: 600;">
              View & Accept Alternative Dates
            </a>
          </p>
        `;
      }

      const mailOptions = {
        from: process.env.EMAIL_FROM,
        to: booking.email,
        replyTo: process.env.GMAIL_USER,
        subject: `More House School - Tour Request Update`,
        text: `Dear ${booking.parent_first_name} ${booking.parent_last_name},

Thank you for your interest in More House School.

Unfortunately, your requested date is not available.

${decline_reason ? `Reason: ${decline_reason}\n` : ''}${alternativesText}

${!hasAlternatives ? 'Please reply to this email to discuss alternative arrangements or submit a new tour request.' : ''}

Best regards,
More House School Admissions Team`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #091825;">Tour Request Update</h2>
            <p>Dear ${booking.parent_first_name} ${booking.parent_last_name},</p>
            <p>Thank you for your interest in More House School.</p>
            <p>Unfortunately, your requested date is not available.</p>

            ${decline_reason ? `<p style="padding: 10px; background: #f8f9fa; border-left: 3px solid #6c757d;"><strong>Reason:</strong> ${decline_reason}</p>` : ''}

            ${alternativesHTML}

            ${!hasAlternatives ? '<p style="margin-top: 20px;">Please reply to this email to discuss alternative arrangements or submit a new tour request.</p>' : ''}

            <p style="margin-top: 30px; color: #666; font-size: 14px;">
              Best regards,<br>
              More House School<br>
              Admissions Team
            </p>
          </div>
        `
      };

      await (await getEmailTransporter()).sendMail(mailOptions);

      // Log email
      await pool.query(
        `INSERT INTO booking_email_logs (booking_id, email_type, recipient, subject, sent_at)
         VALUES ($1, $2, $3, $4, NOW())`,
        [booking.id, 'tour_declined', booking.email, mailOptions.subject]
      );
    } catch (emailError) {
      console.error('Email send error:', emailError);
    }

    res.json({ success: true, booking });
  } catch (error) {
    console.error('Decline booking error:', error);
    res.status(500).json({ success: false, error: 'Failed to decline booking' });
  }
});

// Parent accepts alternative date (Public endpoint)
app.post('/api/bookings/accept-alternative', async (req, res) => {
  try {
    const { token, selected_date, selected_time } = req.body;

    const result = await pool.query(
      `UPDATE bookings SET
        status = 'confirmed',
        scheduled_date = $1,
        scheduled_time = $2,
        decline_reason = NULL,
        alternative_dates = NULL,
        updated_at = NOW()
      WHERE response_token = $3 AND status = 'declined'
      RETURNING *`,
      [selected_date, selected_time, token]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found or already processed' });
    }

    const booking = result.rows[0];

    // Send confirmation email
    try {
      const scheduledDateTime = `${new Date(selected_date).toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })} at ${selected_time}`;

      const mailOptions = {
        from: process.env.EMAIL_FROM,
        to: booking.email,
        replyTo: process.env.GMAIL_USER,
        subject: `More House School - Tour Confirmed for ${scheduledDateTime}`,
        text: `Dear ${booking.parent_first_name} ${booking.parent_last_name},

Thank you for selecting an alternative date!

Your tour has been confirmed for:
${scheduledDateTime}

We look forward to welcoming you to More House School!

Best regards,
More House School Admissions Team`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #091825;">Tour Confirmed!</h2>
            <p>Dear ${booking.parent_first_name} ${booking.parent_last_name},</p>
            <p>Thank you for selecting an alternative date!</p>
            <p>Your tour has been <strong>confirmed</strong> for:</p>
            <p style="font-size: 18px; color: #091825; font-weight: 600;">${scheduledDateTime}</p>
            <p style="margin-top: 20px;">We look forward to welcoming you to More House School!</p>
            <p style="margin-top: 30px; color: #666; font-size: 14px;">
              Best regards,<br>
              More House School<br>
              Admissions Team
            </p>
          </div>
        `
      };

      await (await getEmailTransporter()).sendMail(mailOptions);

      // Log email
      await pool.query(
        `INSERT INTO booking_email_logs (booking_id, email_type, recipient, subject, sent_at)
         VALUES ($1, $2, $3, $4, NOW())`,
        [booking.id, 'alternative_accepted', booking.email, mailOptions.subject]
      );
    } catch (emailError) {
      console.error('Email send error:', emailError);
    }

    res.json({ success: true, booking });
  } catch (error) {
    console.error('Accept alternative error:', error);
    res.status(500).json({ success: false, error: 'Failed to accept alternative' });
  }
});

// Get booking by response token (Public endpoint)
app.get('/api/bookings/by-token/:token', async (req, res) => {
  try {
    const { token } = req.params;

    const result = await pool.query(
      'SELECT * FROM bookings WHERE response_token = $1',
      [token]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    res.json({ success: true, booking: result.rows[0] });
  } catch (error) {
    console.error('Get booking by token error:', error);
    res.status(500).json({ success: false, error: 'Failed to get booking' });
  }
});

// Cancel booking via token (Public endpoint)
app.post('/api/bookings/cancel', async (req, res) => {
  try {
    const { token, reason } = req.body;

    const result = await pool.query(
      `UPDATE bookings SET
        status = 'cancelled',
        cancelled_at = NOW(),
        cancellation_reason = $1,
        updated_at = NOW()
      WHERE cancellation_token = $2 AND status != 'cancelled'
      RETURNING *`,
      [reason || 'Cancelled by user', token]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found or already cancelled' });
    }

    const booking = result.rows[0];

    // Update event booking count
    await pool.query(
      'UPDATE events SET current_bookings = current_bookings - $1 WHERE id = $2',
      [booking.num_attendees, booking.event_id]
    );

    res.json({ success: true, message: 'Booking cancelled successfully' });
  } catch (error) {
    console.error('Cancel booking error:', error);
    res.status(500).json({ success: false, error: 'Failed to cancel booking' });
  }
});

// ==================== TOUR GUIDES ENDPOINTS ====================

// Get all tour guides for a school
app.get('/api/tour-guides', async (req, res) => {
  try {
    const { schoolId } = req.query;

    const result = await pool.query(
      'SELECT * FROM tour_guides WHERE school_id = $1 ORDER BY name ASC',
      [schoolId]
    );

    res.json({ success: true, guides: result.rows });
  } catch (error) {
    console.error('Get tour guides error:', error);
    res.status(500).json({ success: false, error: 'Failed to get tour guides' });
  }
});

// Create tour guide
app.post('/api/tour-guides', async (req, res) => {
  try {
    const { school_id, name, email, phone, type } = req.body;

    const result = await pool.query(
      `INSERT INTO tour_guides (school_id, name, email, phone, type)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING *`,
      [school_id, name, email, phone, type]
    );

    res.json({ success: true, guide: result.rows[0] });
  } catch (error) {
    console.error('Create tour guide error:', error);
    res.status(500).json({ success: false, error: 'Failed to create tour guide' });
  }
});

// Update tour guide
app.put('/api/tour-guides/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, email, phone, type, is_active } = req.body;

    const result = await pool.query(
      `UPDATE tour_guides SET
        name = $1,
        email = $2,
        phone = $3,
        type = $4,
        is_active = $5
      WHERE id = $6
      RETURNING *`,
      [name, email, phone, type, is_active, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Tour guide not found' });
    }

    res.json({ success: true, guide: result.rows[0] });
  } catch (error) {
    console.error('Update tour guide error:', error);
    res.status(500).json({ success: false, error: 'Failed to update tour guide' });
  }
});

// Delete tour guide
app.delete('/api/tour-guides/:id', async (req, res) => {
  try {
    const { id } = req.params;

    await pool.query('DELETE FROM tour_guides WHERE id = $1', [id]);
    res.json({ success: true, message: 'Tour guide deleted successfully' });
  } catch (error) {
    console.error('Delete tour guide error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete tour guide' });
  }
});

// ==================== EMAIL TEMPLATES ENDPOINTS ====================

// Get all email templates for a school
app.get('/api/email-templates', async (req, res) => {
  try {
    const schoolId = req.query.schoolId || 2;
    const result = await pool.query(
      'SELECT * FROM email_templates WHERE school_id = $1 ORDER BY created_at DESC',
      [schoolId]
    );
    res.json({ success: true, templates: result.rows });
  } catch (error) {
    console.error('Get email templates error:', error);
    res.status(500).json({ success: false, error: 'Failed to fetch email templates' });
  }
});

// Create new email template
app.post('/api/email-templates', async (req, res) => {
  try {
    const {
      schoolId = 2,
      name,
      templateType,
      subject,
      body,
      isActive = true,
      enableAutomation = false,
      automationTrigger = null,
      automationDays = null,
      automationTiming = null
    } = req.body;

    const result = await pool.query(
      `INSERT INTO email_templates
       (school_id, name, template_type, subject, body, is_active, enable_automation,
        automation_trigger, automation_days, automation_timing)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
       RETURNING *`,
      [schoolId, name, templateType, subject, body, isActive, enableAutomation,
       automationTrigger, automationDays, automationTiming]
    );

    res.json({ success: true, template: result.rows[0] });
  } catch (error) {
    console.error('Create email template error:', error);
    res.status(500).json({ success: false, error: 'Failed to create email template' });
  }
});

// Update email template
app.put('/api/email-templates/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name,
      templateType,
      subject,
      body,
      isActive,
      enableAutomation,
      automationTrigger,
      automationDays,
      automationTiming
    } = req.body;

    const result = await pool.query(
      `UPDATE email_templates
       SET name = $1, template_type = $2, subject = $3, body = $4, is_active = $5,
           enable_automation = $6, automation_trigger = $7, automation_days = $8,
           automation_timing = $9, updated_at = CURRENT_TIMESTAMP
       WHERE id = $10
       RETURNING *`,
      [name, templateType, subject, body, isActive, enableAutomation,
       automationTrigger, automationDays, automationTiming, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Template not found' });
    }

    res.json({ success: true, template: result.rows[0] });
  } catch (error) {
    console.error('Update email template error:', error);
    res.status(500).json({ success: false, error: 'Failed to update email template' });
  }
});

// Delete email template
app.delete('/api/email-templates/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(
      'DELETE FROM email_templates WHERE id = $1 RETURNING id',
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Template not found' });
    }

    res.json({ success: true, message: 'Email template deleted successfully' });
  } catch (error) {
    console.error('Delete email template error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete email template' });
  }
});

// ==================== FORM TEMPLATE ENDPOINTS ====================

// Get settings (includes prospectus integration info)
app.get('/api/settings', async (req, res) => {
  try {
    // Default to school_id = 2 (More House)
    const schoolId = 2;

    const result = await pool.query(
      'SELECT * FROM booking_settings WHERE school_id = $1',
      [schoolId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Settings not found' });
    }

    res.json({ success: true, settings: result.rows[0] });
  } catch (error) {
    console.error('Get settings error:', error);
    res.status(500).json({ success: false, error: 'Failed to get settings' });
  }
});

// Get active form template for a school
app.get('/api/form-template', async (req, res) => {
  try {
    // Default to school_id = 2 (More House)
    const schoolId = 2;

    // Get active template
    const templateResult = await pool.query(
      'SELECT * FROM enquiry_form_templates WHERE school_id = $1 AND is_active = true LIMIT 1',
      [schoolId]
    );

    if (templateResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'No active form template found' });
    }

    const template = templateResult.rows[0];

    // Get form fields for this template
    const fieldsResult = await pool.query(
      'SELECT * FROM enquiry_form_fields WHERE template_id = $1 ORDER BY display_order',
      [template.id]
    );

    res.json({
      success: true,
      template: {
        ...template,
        fields: fieldsResult.rows
      }
    });
  } catch (error) {
    console.error('Get form template error:', error);
    res.status(500).json({ success: false, error: 'Failed to get form template' });
  }
});

// Submit enquiry form
app.post('/api/form-submit', async (req, res) => {
  try {
    const formData = req.body;

    // Get school_id from booking_settings (form builder schools only)
    const settingsResult = await pool.query(
      'SELECT school_id FROM booking_settings WHERE school_id NOT IN (SELECT school_id FROM inquiries WHERE school_id IS NOT NULL) OR school_id = (SELECT MAX(school_id) FROM booking_settings) LIMIT 1'
    );

    let schoolId;
    if (settingsResult.rows.length > 0) {
      schoolId = settingsResult.rows[0].school_id;
    } else {
      // Create new school_id
      const maxIdResult = await pool.query('SELECT COALESCE(MAX(school_id), 0) + 1 AS new_id FROM booking_settings');
      schoolId = maxIdResult.rows[0].new_id;
    }

    // Generate unique inquiry ID
    const inquiryId = `INQ-${Date.now()}${Math.floor(Math.random() * 10000)}`;

    // Insert basic info into inquiries table
    const result = await pool.query(
      `INSERT INTO inquiries (
        inquiry_id, school_id, parent_name, parent_email, contact_number,
        first_name, family_surname, age_group, entry_year
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING inquiry_id`,
      [
        inquiryId,
        schoolId,
        formData.parent_name || null,
        formData.parent_email || null,
        formData.contact_number || null,
        formData.first_name || null,
        formData.family_surname || null,
        formData.age_group || null,
        formData.entry_year || null
      ]
    );

    res.json({
      success: true,
      inquiry_id: result.rows[0].inquiry_id,
      message: 'Enquiry submitted successfully'
    });
  } catch (error) {
    console.error('Form submit error:', error);
    res.status(500).json({ success: false, error: 'Failed to submit enquiry form' });
  }
});

// ==================== FORM TEMPLATE MANAGEMENT ENDPOINTS ====================

// Get form template with fields for editing
app.get('/api/form-template/manage', async (req, res) => {
  try {
    const schoolId = 2; // More House School

    // Get active template
    const templateResult = await pool.query(
      'SELECT * FROM enquiry_form_templates WHERE school_id = $1 AND is_active = true LIMIT 1',
      [schoolId]
    );

    if (templateResult.rows.length === 0) {
      return res.json({ success: true, template: null, fields: [] });
    }

    const template = templateResult.rows[0];

    // Get form fields for this template
    const fieldsResult = await pool.query(
      'SELECT * FROM enquiry_form_fields WHERE template_id = $1 ORDER BY display_order',
      [template.id]
    );

    res.json({
      success: true,
      template: template,
      fields: fieldsResult.rows
    });
  } catch (error) {
    console.error('Get form template for management error:', error);
    res.status(500).json({ success: false, error: 'Failed to get form template' });
  }
});

// Update form template
app.put('/api/form-template/:templateId', async (req, res) => {
  try {
    const { templateId } = req.params;
    const { name, description } = req.body;

    const result = await pool.query(
      `UPDATE enquiry_form_templates
       SET name = $1, description = $2, updated_at = CURRENT_TIMESTAMP
       WHERE id = $3
       RETURNING *`,
      [name, description, templateId]
    );

    res.json({ success: true, template: result.rows[0] });
  } catch (error) {
    console.error('Update form template error:', error);
    res.status(500).json({ success: false, error: 'Failed to update form template' });
  }
});

// Create new form field
app.post('/api/form-field', async (req, res) => {
  try {
    const {
      template_id,
      field_label,
      field_type,
      field_options,
      is_required,
      placeholder,
      help_text,
      display_order,
      maps_to_inquiry_column,
      show_for_gender,
      section_id
    } = req.body;

    // Auto-generate field_name based on the highest existing field number
    const maxFieldResult = await pool.query(
      `SELECT field_name FROM enquiry_form_fields
       WHERE template_id = $1 AND field_name LIKE 'field_%'
       ORDER BY CAST(SUBSTRING(field_name FROM 7) AS INTEGER) DESC
       LIMIT 1`,
      [template_id]
    );

    let nextFieldNumber = 1;
    if (maxFieldResult.rows.length > 0) {
      const maxFieldName = maxFieldResult.rows[0].field_name;
      const currentNumber = parseInt(maxFieldName.replace('field_', ''));
      nextFieldNumber = currentNumber + 1;
    } else {
      // Check if there are any fields at all (including legacy ones)
      const countResult = await pool.query(
        'SELECT COUNT(*) as count FROM enquiry_form_fields WHERE template_id = $1',
        [template_id]
      );
      nextFieldNumber = parseInt(countResult.rows[0].count) + 1;
    }

    const field_name = `field_${nextFieldNumber}`;

    // Push down all fields at or after the new display_order
    await pool.query(
      `UPDATE enquiry_form_fields
       SET display_order = display_order + 1
       WHERE template_id = $1 AND display_order >= $2`,
      [template_id, display_order]
    );

    const result = await pool.query(
      `INSERT INTO enquiry_form_fields (
        template_id, field_name, field_label, field_type, field_options,
        is_required, placeholder, help_text, display_order, maps_to_inquiry_column, show_for_gender, section_id
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      RETURNING *`,
      [
        template_id, field_name, field_label, field_type, field_options,
        is_required, placeholder, help_text, display_order, maps_to_inquiry_column, show_for_gender || 'both', section_id || null
      ]
    );

    res.json({ success: true, field: result.rows[0] });
  } catch (error) {
    console.error('Create form field error:', error);
    res.status(500).json({ success: false, error: 'Failed to create form field' });
  }
});

// Update form field
app.put('/api/form-field/:fieldId', async (req, res) => {
  try {
    const { fieldId } = req.params;
    const {
      field_label,
      field_type,
      field_options,
      is_required,
      placeholder,
      help_text,
      display_order,
      maps_to_inquiry_column,
      show_for_gender,
      section_id
    } = req.body;

    // Get the current field's display_order and template_id
    const currentFieldResult = await pool.query(
      'SELECT display_order, template_id FROM enquiry_form_fields WHERE id = $1',
      [fieldId]
    );

    if (currentFieldResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Field not found' });
    }

    const oldDisplayOrder = currentFieldResult.rows[0].display_order;
    const template_id = currentFieldResult.rows[0].template_id;
    const newDisplayOrder = display_order;

    // If display order is changing, adjust other fields
    if (oldDisplayOrder !== newDisplayOrder) {
      if (newDisplayOrder < oldDisplayOrder) {
        // Moving up: push down fields between new and old position
        await pool.query(
          `UPDATE enquiry_form_fields
           SET display_order = display_order + 1
           WHERE template_id = $1 AND display_order >= $2 AND display_order < $3 AND id != $4`,
          [template_id, newDisplayOrder, oldDisplayOrder, fieldId]
        );
      } else {
        // Moving down: pull up fields between old and new position
        await pool.query(
          `UPDATE enquiry_form_fields
           SET display_order = display_order - 1
           WHERE template_id = $1 AND display_order > $2 AND display_order <= $3 AND id != $4`,
          [template_id, oldDisplayOrder, newDisplayOrder, fieldId]
        );
      }
    }

    // field_name is NOT updated - it stays the same
    const result = await pool.query(
      `UPDATE enquiry_form_fields
       SET field_label = $1, field_type = $2, field_options = $3,
           is_required = $4, placeholder = $5, help_text = $6, display_order = $7,
           maps_to_inquiry_column = $8, show_for_gender = $9, section_id = $10
       WHERE id = $11
       RETURNING *`,
      [
        field_label, field_type, field_options, is_required,
        placeholder, help_text, display_order, maps_to_inquiry_column,
        show_for_gender || 'both', section_id || null, fieldId
      ]
    );

    res.json({ success: true, field: result.rows[0] });
  } catch (error) {
    console.error('Update form field error:', error);
    res.status(500).json({ success: false, error: 'Failed to update form field' });
  }
});

// Delete form field
app.delete('/api/form-field/:fieldId', async (req, res) => {
  try {
    const { fieldId } = req.params;

    // Get the field's display_order and template_id before deleting
    const fieldResult = await pool.query(
      'SELECT display_order, template_id FROM enquiry_form_fields WHERE id = $1',
      [fieldId]
    );

    if (fieldResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Field not found' });
    }

    const deletedDisplayOrder = fieldResult.rows[0].display_order;
    const template_id = fieldResult.rows[0].template_id;

    // Delete the field
    await pool.query('DELETE FROM enquiry_form_fields WHERE id = $1', [fieldId]);

    // Pull up all fields after the deleted field
    await pool.query(
      `UPDATE enquiry_form_fields
       SET display_order = display_order - 1
       WHERE template_id = $1 AND display_order > $2`,
      [template_id, deletedDisplayOrder]
    );

    res.json({ success: true, message: 'Form field deleted successfully' });
  } catch (error) {
    console.error('Delete form field error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete form field' });
  }
});

// ==================== FORM SECTIONS ENDPOINTS ====================

// Get all sections for a template
app.get('/api/form-sections/:templateId', async (req, res) => {
  try {
    const { templateId } = req.params;
    const result = await pool.query(
      'SELECT * FROM enquiry_form_sections WHERE template_id = $1 ORDER BY display_order ASC',
      [templateId]
    );
    res.json({ success: true, sections: result.rows });
  } catch (error) {
    console.error('Get form sections error:', error);
    res.status(500).json({ success: false, error: 'Failed to get form sections' });
  }
});

// Create new section
app.post('/api/form-section', async (req, res) => {
  try {
    const { template_id, section_name, section_label, display_order } = req.body;

    const result = await pool.query(
      `INSERT INTO enquiry_form_sections (
        template_id, section_name, section_label, display_order
      ) VALUES ($1, $2, $3, $4)
      RETURNING *`,
      [template_id, section_name, section_label, display_order || 0]
    );

    res.json({ success: true, section: result.rows[0] });
  } catch (error) {
    console.error('Create form section error:', error);
    res.status(500).json({ success: false, error: 'Failed to create form section' });
  }
});

// Update section
app.put('/api/form-section/:sectionId', async (req, res) => {
  try {
    const { sectionId } = req.params;
    const { section_label, display_order } = req.body;

    const result = await pool.query(
      `UPDATE enquiry_form_sections
       SET section_label = $1, display_order = $2
       WHERE id = $3
       RETURNING *`,
      [section_label, display_order, sectionId]
    );

    res.json({ success: true, section: result.rows[0] });
  } catch (error) {
    console.error('Update form section error:', error);
    res.status(500).json({ success: false, error: 'Failed to update form section' });
  }
});

// Delete section
app.delete('/api/form-section/:sectionId', async (req, res) => {
  try {
    const { sectionId } = req.params;

    // Set fields in this section to have no section (section_id = NULL)
    await pool.query('UPDATE enquiry_form_fields SET section_id = NULL WHERE section_id = $1', [sectionId]);

    // Delete the section
    await pool.query('DELETE FROM enquiry_form_sections WHERE id = $1', [sectionId]);

    res.json({ success: true, message: 'Form section deleted successfully' });
  } catch (error) {
    console.error('Delete form section error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete form section' });
  }
});

// ==================== AUTHENTICATION ENDPOINTS ====================

// Check auth status
app.get('/api/auth/status', (req, res) => {
  if (req.session && req.session.userId) {
    res.json({ authenticated: true, userId: req.session.userId });
  } else {
    res.json({ authenticated: false });
  }
});

// Logout
app.post('/api/auth/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ success: false, error: 'Logout failed' });
    }
    res.json({ success: true });
  });
});

// ==================== FEEDBACK & OUTCOMES ENDPOINTS ====================

// Get active feedback questions
app.get('/api/feedback/questions', async (req, res) => {
  try {
    const { booking_id, token } = req.query;
    let formId = null;

    // If booking_id or token provided, get the assigned form for that booking
    if (booking_id || token) {
      const bookingQuery = token
        ? 'SELECT b.*, e.assigned_feedback_form_id FROM bookings b LEFT JOIN events e ON e.id = b.event_id WHERE b.feedback_token = $1'
        : 'SELECT b.*, e.assigned_feedback_form_id FROM bookings b LEFT JOIN events e ON e.id = b.event_id WHERE b.id = $1';

      const bookingResult = await pool.query(bookingQuery, [token || booking_id]);

      if (bookingResult.rows.length > 0) {
        const booking = bookingResult.rows[0];

        // Use the assigned form from the event if available
        if (booking.assigned_feedback_form_id) {
          formId = booking.assigned_feedback_form_id;
        } else {
          // Fall back to default form based on booking type
          const defaultFormQuery = booking.booking_type === 'open_day'
            ? `SELECT id FROM feedback_forms WHERE school_id = 2 AND form_type = 'open_day' AND is_active = true ORDER BY id LIMIT 1`
            : `SELECT id FROM feedback_forms WHERE school_id = 2 AND form_type = 'private_tour' AND is_active = true ORDER BY id LIMIT 1`;

          const defaultFormResult = await pool.query(defaultFormQuery);
          if (defaultFormResult.rows.length > 0) {
            formId = defaultFormResult.rows[0].id;
          }
        }
      }
    }

    // Load questions from the identified form
    let query = 'SELECT * FROM feedback_questions WHERE school_id = 2 AND is_active = true';
    const params = [];

    if (formId) {
      query += ' AND form_id = $1';
      params.push(formId);
    }

    query += ' ORDER BY display_order ASC';

    const result = await pool.query(query, params);
    res.json({ success: true, questions: result.rows });
  } catch (error) {
    console.error('Get feedback questions error:', error);
    res.status(500).json({ success: false, error: 'Failed to get feedback questions' });
  }
});

// Get booking by feedback token
app.get('/api/feedback/booking/:token', async (req, res) => {
  try {
    const { token } = req.params;

    const result = await pool.query(
      `SELECT b.*,
        EXISTS(SELECT 1 FROM feedback_responses WHERE booking_id = b.id) as feedback_submitted
       FROM bookings b
       WHERE b.feedback_token = $1`,
      [token]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    res.json({ success: true, booking: result.rows[0] });
  } catch (error) {
    console.error('Get booking by feedback token error:', error);
    res.status(500).json({ success: false, error: 'Failed to get booking' });
  }
});

// Submit feedback
app.post('/api/feedback/submit', async (req, res) => {
  try {
    const { token, responses } = req.body;

    // Get booking by token
    const bookingResult = await pool.query(
      'SELECT id FROM bookings WHERE feedback_token = $1',
      [token]
    );

    if (bookingResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Booking not found' });
    }

    const bookingId = bookingResult.rows[0].id;

    // Check if already submitted
    const existingResult = await pool.query(
      'SELECT id FROM feedback_responses WHERE booking_id = $1',
      [bookingId]
    );

    if (existingResult.rows.length > 0) {
      return res.status(400).json({ success: false, error: 'Feedback already submitted' });
    }

    // Insert responses
    for (const [questionId, response] of Object.entries(responses)) {
      await pool.query(
        `INSERT INTO feedback_responses (booking_id, question_id, response_value, rating_value)
         VALUES ($1, $2, $3, $4)`,
        [
          bookingId,
          parseInt(questionId),
          response.value?.toString(),
          response.type === 'rating' ? response.value : null
        ]
      );
    }

    console.log(`âœ… Feedback submitted for booking ${bookingId}`);
    res.json({ success: true });
  } catch (error) {
    console.error('Submit feedback error:', error);
    res.status(500).json({ success: false, error: 'Failed to submit feedback' });
  }
});

// ==================== FEEDBACK FORMS MANAGEMENT ====================

// Get all feedback forms
app.get('/api/admin/feedback-forms', async (req, res) => {
  try {
    const schoolId = 2;
    const result = await pool.query(
      'SELECT * FROM feedback_forms WHERE school_id = $1 ORDER BY form_type, form_name',
      [schoolId]
    );
    res.json({ success: true, forms: result.rows });
  } catch (error) {
    console.error('Get feedback forms error:', error);
    res.status(500).json({ success: false, error: 'Failed to get forms' });
  }
});

// Create feedback form
app.post('/api/admin/feedback-forms', async (req, res) => {
  try {
    const { form_name, form_type, description } = req.body;
    const schoolId = 2;

    const result = await pool.query(
      `INSERT INTO feedback_forms (school_id, form_name, form_type, description)
       VALUES ($1, $2, $3, $4) RETURNING *`,
      [schoolId, form_name, form_type, description]
    );

    res.json({ success: true, form: result.rows[0] });
  } catch (error) {
    console.error('Create feedback form error:', error);
    res.status(500).json({ success: false, error: 'Failed to create form' });
  }
});

// Update feedback form
app.put('/api/admin/feedback-forms/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { form_name, form_type, description, is_active } = req.body;

    const result = await pool.query(
      `UPDATE feedback_forms
       SET form_name = $1, form_type = $2, description = $3, is_active = $4, updated_at = NOW()
       WHERE id = $5 RETURNING *`,
      [form_name, form_type, description, is_active, id]
    );

    res.json({ success: true, form: result.rows[0] });
  } catch (error) {
    console.error('Update feedback form error:', error);
    res.status(500).json({ success: false, error: 'Failed to update form' });
  }
});

// Delete feedback form
app.delete('/api/admin/feedback-forms/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await pool.query('DELETE FROM feedback_forms WHERE id = $1', [id]);
    res.json({ success: true });
  } catch (error) {
    console.error('Delete feedback form error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete form' });
  }
});

// Assign feedback form to event
app.put('/api/events/:id/assign-form', async (req, res) => {
  try {
    const { id } = req.params;
    const { form_id } = req.body;

    const result = await pool.query(
      `UPDATE events SET assigned_feedback_form_id = $1, updated_at = NOW()
       WHERE id = $2 RETURNING *`,
      [form_id, id]
    );

    res.json({ success: true, event: result.rows[0] });
  } catch (error) {
    console.error('Assign form to event error:', error);
    res.status(500).json({ success: false, error: 'Failed to assign form' });
  }
});

// Get all feedback questions (admin) - optionally filtered by form_id
app.get('/api/admin/feedback-questions', async (req, res) => {
  try {
    const { form_id } = req.query;

    let query = 'SELECT * FROM feedback_questions WHERE school_id = 2';
    const params = [];

    if (form_id) {
      query += ' AND form_id = $1';
      params.push(form_id);
    }

    query += ' ORDER BY display_order ASC';

    const result = await pool.query(query, params);
    res.json({ success: true, questions: result.rows });
  } catch (error) {
    console.error('Get admin feedback questions error:', error);
    res.status(500).json({ success: false, error: 'Failed to get questions' });
  }
});

// Create feedback question
app.post('/api/admin/feedback-questions', async (req, res) => {
  try {
    const { question_text, question_type, options, display_order, form_id } = req.body;

    const result = await pool.query(
      `INSERT INTO feedback_questions (school_id, question_text, question_type, options, display_order, form_id)
       VALUES (2, $1, $2, $3, $4, $5)
       RETURNING *`,
      [question_text, question_type, options ? JSON.stringify(options) : null, display_order || 0, form_id]
    );

    res.json({ success: true, question: result.rows[0] });
  } catch (error) {
    console.error('Create feedback question error:', error);
    res.status(500).json({ success: false, error: 'Failed to create question' });
  }
});

// Update feedback question
app.put('/api/admin/feedback-questions/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { question_text, question_type, options, is_active, display_order } = req.body;

    const result = await pool.query(
      `UPDATE feedback_questions
       SET question_text = $1, question_type = $2, options = $3, is_active = $4, display_order = $5, updated_at = NOW()
       WHERE id = $6
       RETURNING *`,
      [question_text, question_type, options ? JSON.stringify(options) : null, is_active, display_order, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Question not found' });
    }

    res.json({ success: true, question: result.rows[0] });
  } catch (error) {
    console.error('Update feedback question error:', error);
    res.status(500).json({ success: false, error: 'Failed to update question' });
  }
});

// Delete feedback question
app.delete('/api/admin/feedback-questions/:id', async (req, res) => {
  try {
    const { id } = req.params;

    await pool.query('DELETE FROM feedback_questions WHERE id = $1', [id]);

    res.json({ success: true });
  } catch (error) {
    console.error('Delete feedback question error:', error);
    res.status(500).json({ success: false, error: 'Failed to delete question' });
  }
});

// Get booking outcome
app.get('/api/bookings/:id/outcome', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      'SELECT * FROM booking_outcomes WHERE booking_id = $1',
      [id]
    );

    if (result.rows.length === 0) {
      res.json({ success: true, outcome: null });
    } else {
      res.json({ success: true, outcome: result.rows[0] });
    }
  } catch (error) {
    console.error('Get booking outcome error:', error);
    res.status(500).json({ success: false, error: 'Failed to get outcome' });
  }
});

// Update booking outcome
app.put('/api/bookings/:id/outcome', async (req, res) => {
  try {
    const { id } = req.params;
    const { outcome_status, outcome_date, enrollment_year, notes } = req.body;

    const result = await pool.query(
      `INSERT INTO booking_outcomes (booking_id, outcome_status, outcome_date, enrollment_year, notes)
       VALUES ($1, $2, $3, $4, $5)
       ON CONFLICT (booking_id) DO UPDATE
       SET outcome_status = $2, outcome_date = $3, enrollment_year = $4, notes = $5, updated_at = NOW()
       RETURNING *`,
      [id, outcome_status, outcome_date, enrollment_year, notes]
    );

    res.json({ success: true, outcome: result.rows[0] });
  } catch (error) {
    console.error('Update booking outcome error:', error);
    res.status(500).json({ success: false, error: 'Failed to update outcome' });
  }
});

// ==================== ANALYTICS ENDPOINTS ====================

// Get feedback statistics
app.get('/api/analytics/feedback-stats', isAuthenticated, async (req, res) => {
  try {
    const { days = '30', type = 'all' } = req.query;
    const schoolId = 2;

    let dateCondition = '';
    if (days !== '999999') {
      dateCondition = `AND b.created_at >= NOW() - INTERVAL '${parseInt(days)} days'`;
    }

    let typeCondition = '';
    if (type !== 'all') {
      typeCondition = `AND b.booking_type = '${type}'`;
    }

    // Get overall stats
    const statsResult = await pool.query(`
      SELECT
        COUNT(DISTINCT b.id) as total_bookings,
        COUNT(DISTINCT CASE WHEN EXISTS(SELECT 1 FROM feedback_responses WHERE booking_id = b.id) THEN b.id END) as responses_count,
        ROUND(AVG(fr.rating_value)::numeric, 2) as avg_rating,
        COUNT(DISTINCT CASE WHEN bo.outcome_status = 'enrolled' THEN b.id END) as enrolled_count
      FROM bookings b
      LEFT JOIN feedback_responses fr ON fr.booking_id = b.id
      LEFT JOIN booking_outcomes bo ON bo.booking_id = b.id
      WHERE b.school_id = $1
        AND b.status = 'confirmed'
        AND b.checked_in_at IS NOT NULL
        ${dateCondition}
        ${typeCondition}
    `, [schoolId]);

    const stats = statsResult.rows[0];
    const response_rate = stats.total_bookings > 0
      ? (stats.responses_count / stats.total_bookings) * 100
      : 0;
    const conversion_rate = stats.responses_count > 0
      ? (stats.enrolled_count / stats.responses_count) * 100
      : 0;

    res.json({
      success: true,
      stats: {
        ...stats,
        response_rate: Math.round(response_rate),
        conversion_rate: Math.round(conversion_rate)
      }
    });
  } catch (error) {
    console.error('Get feedback stats error:', error);
    res.status(500).json({ success: false, error: 'Failed to get feedback stats' });
  }
});

// Get question-by-question analytics
app.get('/api/analytics/feedback-questions', isAuthenticated, async (req, res) => {
  try {
    const { days = '30', type = 'all' } = req.query;
    const schoolId = 2;

    let dateCondition = '';
    if (days !== '999999') {
      dateCondition = `AND b.created_at >= NOW() - INTERVAL '${parseInt(days)} days'`;
    }

    let typeCondition = '';
    if (type !== 'all') {
      typeCondition = `AND b.booking_type = '${type}'`;
    }

    const questionsResult = await pool.query(`
      SELECT DISTINCT fq.id, fq.question_text, fq.question_type, fq.display_order
      FROM feedback_questions fq
      WHERE fq.school_id = $1 AND fq.is_active = true
      ORDER BY fq.display_order ASC
    `, [schoolId]);

    const questions = [];

    for (const question of questionsResult.rows) {
      if (question.question_type === 'rating') {
        // Get rating analytics
        const ratingsResult = await pool.query(`
          SELECT
            COUNT(*) as response_count,
            ROUND(AVG(fr.rating_value)::numeric, 2) as avg_rating,
            COUNT(CASE WHEN fr.rating_value = 5 THEN 1 END) as rating_5,
            COUNT(CASE WHEN fr.rating_value = 4 THEN 1 END) as rating_4,
            COUNT(CASE WHEN fr.rating_value = 3 THEN 1 END) as rating_3,
            COUNT(CASE WHEN fr.rating_value = 2 THEN 1 END) as rating_2,
            COUNT(CASE WHEN fr.rating_value = 1 THEN 1 END) as rating_1
          FROM feedback_responses fr
          JOIN bookings b ON b.id = fr.booking_id
          WHERE fr.question_id = $1
            ${dateCondition}
            ${typeCondition}
        `, [question.id]);

        const ratings = ratingsResult.rows[0];

        questions.push({
          ...question,
          response_count: parseInt(ratings.response_count) || 0,
          avg_rating: ratings.avg_rating || 0,
          rating_breakdown: {
            5: parseInt(ratings.rating_5) || 0,
            4: parseInt(ratings.rating_4) || 0,
            3: parseInt(ratings.rating_3) || 0,
            2: parseInt(ratings.rating_2) || 0,
            1: parseInt(ratings.rating_1) || 0
          }
        });
      } else if (question.question_type === 'text') {
        // Get text responses
        const textResult = await pool.query(`
          SELECT
            fr.response_value,
            fr.submitted_at,
            b.parent_first_name || ' ' || b.parent_last_name as parent_name
          FROM feedback_responses fr
          JOIN bookings b ON b.id = fr.booking_id
          WHERE fr.question_id = $1
            AND fr.response_value IS NOT NULL
            AND fr.response_value != ''
            ${dateCondition}
            ${typeCondition}
          ORDER BY fr.submitted_at DESC
          LIMIT 50
        `, [question.id]);

        questions.push({
          ...question,
          responses: textResult.rows
        });
      }
    }

    res.json({ success: true, questions });
  } catch (error) {
    console.error('Get feedback questions analytics error:', error);
    res.status(500).json({ success: false, error: 'Failed to get question analytics' });
  }
});

// Get conversion outcomes
app.get('/api/analytics/conversion-outcomes', isAuthenticated, async (req, res) => {
  try {
    const { days = '30', type = 'all' } = req.query;
    const schoolId = 2;

    let dateCondition = '';
    if (days !== '999999') {
      dateCondition = `AND b.created_at >= NOW() - INTERVAL '${parseInt(days)} days'`;
    }

    let typeCondition = '';
    if (type !== 'all') {
      typeCondition = `AND b.booking_type = '${type}'`;
    }

    // Get summary counts
    const summaryResult = await pool.query(`
      SELECT
        COUNT(CASE WHEN bo.outcome_status = 'interested' THEN 1 END) as interested,
        COUNT(CASE WHEN bo.outcome_status = 'applied' THEN 1 END) as applied,
        COUNT(CASE WHEN bo.outcome_status = 'enrolled' THEN 1 END) as enrolled,
        COUNT(CASE WHEN bo.outcome_status = 'declined' THEN 1 END) as declined,
        COUNT(CASE WHEN bo.outcome_status IS NULL THEN 1 END) as no_response
      FROM bookings b
      LEFT JOIN booking_outcomes bo ON bo.booking_id = b.id
      WHERE b.school_id = $1
        AND b.status = 'confirmed'
        AND b.checked_in_at IS NOT NULL
        ${dateCondition}
        ${typeCondition}
    `, [schoolId]);

    // Get detailed outcomes
    const outcomesResult = await pool.query(`
      SELECT
        b.id,
        b.parent_first_name || ' ' || b.parent_last_name as parent_name,
        b.student_first_name || ' ' || COALESCE(b.student_last_name, '') as student_name,
        COALESCE(e.event_date, b.scheduled_date) as tour_date,
        b.booking_type,
        bo.outcome_status,
        bo.enrollment_year,
        bo.outcome_date,
        bo.notes
      FROM bookings b
      LEFT JOIN events e ON e.id = b.event_id
      LEFT JOIN booking_outcomes bo ON bo.booking_id = b.id
      WHERE b.school_id = $1
        AND b.status = 'confirmed'
        AND b.checked_in_at IS NOT NULL
        ${dateCondition}
        ${typeCondition}
      ORDER BY bo.updated_at DESC NULLS LAST, b.created_at DESC
      LIMIT 100
    `, [schoolId]);

    res.json({
      success: true,
      summary: summaryResult.rows[0],
      outcomes: outcomesResult.rows
    });
  } catch (error) {
    console.error('Get conversion outcomes error:', error);
    res.status(500).json({ success: false, error: 'Failed to get conversion outcomes' });
  }
});

// ==================== AUTOMATED EMAIL SCHEDULER ====================

// Helper function to send template-based email
async function sendTemplateEmail(booking, templateId, emailType) {
  try {
    // Fetch template
    const template = await pool.query('SELECT * FROM email_templates WHERE id = $1', [templateId]);
    if (template.rows.length === 0) {
      console.error(`Template ${templateId} not found`);
      return false;
    }

    // Ensure booking has a feedback_token (generate if missing)
    let feedbackToken = booking.feedback_token;
    if (!feedbackToken) {
      feedbackToken = crypto.randomBytes(32).toString('hex');
      await pool.query(
        'UPDATE bookings SET feedback_token = $1 WHERE id = $2',
        [feedbackToken, booking.id]
      );
      console.log(`âœ“ Generated feedback token for booking #${booking.id}`);
    }

    // Prepare template data
    const eventDate = booking.event_date || booking.scheduled_date;
    const eventTime = booking.start_time || booking.scheduled_time;
    const feedbackUrl = `${process.env.APP_URL || 'http://localhost:3002'}/feedback.html?token=${feedbackToken}`;

    const templateData = {
      parent_name: `${booking.parent_first_name} ${booking.parent_last_name}`,
      student_name: `${booking.student_first_name} ${booking.student_last_name || ''}`.trim(),
      school_name: 'More House School',
      tour_date: eventDate ? new Date(eventDate).toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) : '',
      tour_time: eventTime || '',
      event_date: eventDate ? new Date(eventDate).toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) : '',
      start_time: eventTime || '',
      event_title: booking.event_title || 'Your Event',
      num_attendees: booking.num_attendees || 1,
      tour_guide: booking.guide_name || 'our tour guide',
      feedback_link: feedbackUrl
    };

    // Replace template variables
    let subject = template.rows[0].subject;
    let body = template.rows[0].body;

    Object.keys(templateData).forEach(key => {
      const regex = new RegExp(`{{${key}}}`, 'g');
      subject = subject.replace(regex, templateData[key]);
      body = body.replace(regex, templateData[key]);
    });

    // Send email
    await (await getEmailTransporter()).sendMail({
      from: process.env.GMAIL_USER,
      to: booking.email,
      subject: subject,
      text: body,
      html: body.replace(/\n/g, '<br>')
    });

    // Mark as sent in scheduled_emails
    await pool.query(
      'UPDATE scheduled_emails SET status = $1, sent_at = CURRENT_TIMESTAMP WHERE booking_id = $2 AND email_type = $3',
      ['sent', booking.id, emailType]
    );

    console.log(`âœ“ Sent ${emailType} email to ${booking.email} for booking #${booking.id}`);
    return true;
  } catch (error) {
    console.error(`Failed to send ${emailType} email for booking #${booking.id}:`, error);

    // Log error in scheduled_emails
    await pool.query(
      'UPDATE scheduled_emails SET status = $1, error_message = $2 WHERE booking_id = $3 AND email_type = $4',
      ['failed', error.message, booking.id, emailType]
    ).catch(e => console.error('Failed to log error:', e));

    return false;
  }
}

// Send first reminder emails (configurable days before)
async function send7DayReminders() {
  try {
    // Get reminder timing from settings
    const settingsResult = await pool.query(
      'SELECT reminder_days_before_1 FROM booking_settings WHERE school_id = 2'
    );
    const reminderDays = settingsResult.rows[0]?.reminder_days_before_1 || 7;

    console.log(`\n[First Reminder] Checking for bookings ${reminderDays} days from now`);

    // Find bookings with events/tours X days from now
    const result = await pool.query(`
      SELECT DISTINCT ON (b.id) b.*, e.title as event_title, e.event_date, e.start_time,
             tg.name as guide_name
      FROM bookings b
      LEFT JOIN events e ON b.event_id = e.id
      LEFT JOIN tour_guides tg ON b.assigned_guide_id = tg.id
      WHERE b.school_id = 2
        AND b.status = 'confirmed'
        AND (
          (e.event_date = CURRENT_DATE + INTERVAL '1 day' * $1 AND b.booking_type = 'open_day')
          OR (b.scheduled_date = CURRENT_DATE + INTERVAL '1 day' * $1 AND b.booking_type = 'private_tour')
        )
        AND NOT EXISTS (
          SELECT 1 FROM scheduled_emails
          WHERE booking_id = b.id
          AND email_type = 'reminder_7day'
          AND status IN ('sent', 'pending')
        )
      ORDER BY b.id
    `, [reminderDays]);

    console.log(`\n[First Reminder] Found ${result.rows.length} bookings`);

    for (const booking of result.rows) {
      const templateId = booking.booking_type === 'open_day' ? 3 : 9; // Template IDs for first reminders

      // Create scheduled_emails record
      await pool.query(
        `INSERT INTO scheduled_emails (booking_id, email_type, scheduled_for, template_id, status)
         VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4)
         ON CONFLICT (booking_id, email_type) DO NOTHING`,
        [booking.id, 'reminder_7day', templateId, 'pending']
      );

      await sendTemplateEmail(booking, templateId, 'reminder_7day');
    }
  } catch (error) {
    console.error('Error in send7DayReminders:', error);
  }
}

// Send second reminder emails (configurable days before)
async function send1DayReminders() {
  try {
    // Get reminder timing from settings
    const settingsResult = await pool.query(
      'SELECT reminder_days_before_2 FROM booking_settings WHERE school_id = 2'
    );
    const reminderDays = settingsResult.rows[0]?.reminder_days_before_2 || 1;

    console.log(`\n[Second Reminder] Checking for bookings ${reminderDays} day(s) from now`);

    // Find bookings with events/tours X days from now
    const result = await pool.query(`
      SELECT DISTINCT ON (b.id) b.*, e.title as event_title, e.event_date, e.start_time,
             tg.name as guide_name
      FROM bookings b
      LEFT JOIN events e ON b.event_id = e.id
      LEFT JOIN tour_guides tg ON b.assigned_guide_id = tg.id
      WHERE b.school_id = 2
        AND b.status = 'confirmed'
        AND (
          (e.event_date = CURRENT_DATE + INTERVAL '1 day' * $1 AND b.booking_type = 'open_day')
          OR (b.scheduled_date = CURRENT_DATE + INTERVAL '1 day' * $1 AND b.booking_type = 'private_tour')
        )
        AND NOT EXISTS (
          SELECT 1 FROM scheduled_emails
          WHERE booking_id = b.id
          AND email_type = 'reminder_1day'
          AND status IN ('sent', 'pending')
        )
      ORDER BY b.id
    `, [reminderDays]);

    console.log(`\n[Second Reminder] Found ${result.rows.length} bookings`);

    for (const booking of result.rows) {
      const templateId = booking.booking_type === 'open_day' ? 4 : 10; // Template IDs for second reminders

      // Create scheduled_emails record
      await pool.query(
        `INSERT INTO scheduled_emails (booking_id, email_type, scheduled_for, template_id, status)
         VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4)
         ON CONFLICT (booking_id, email_type) DO NOTHING`,
        [booking.id, 'reminder_1day', templateId, 'pending']
      );

      await sendTemplateEmail(booking, templateId, 'reminder_1day');
    }
  } catch (error) {
    console.error('Error in send1DayReminders:', error);
  }
}

// Send follow-up emails after events (configurable days after)
async function sendFollowUpEmails() {
  try {
    // Get follow-up timing from settings
    const settingsResult = await pool.query(
      'SELECT followup_days_after FROM booking_settings WHERE school_id = 2'
    );
    const followupDays = settingsResult.rows[0]?.followup_days_after || 1;

    console.log(`\n[Follow-ups] Checking for bookings ${followupDays} day(s) ago`);

    // Find bookings with events/tours that happened X days ago and were checked in
    const result = await pool.query(`
      SELECT DISTINCT ON (b.id) b.*, e.title as event_title, e.event_date, e.start_time,
             tg.name as guide_name
      FROM bookings b
      LEFT JOIN events e ON b.event_id = e.id
      LEFT JOIN tour_guides tg ON b.assigned_guide_id = tg.id
      WHERE b.school_id = 2
        AND b.checked_in_at IS NOT NULL
        AND (
          (e.event_date = CURRENT_DATE - INTERVAL '1 day' * $1 AND b.booking_type = 'open_day')
          OR (b.scheduled_date = CURRENT_DATE - INTERVAL '1 day' * $1 AND b.booking_type = 'private_tour')
        )
        AND NOT EXISTS (
          SELECT 1 FROM scheduled_emails
          WHERE booking_id = b.id
          AND email_type = 'followup'
          AND status IN ('sent', 'pending')
        )
      ORDER BY b.id
    `, [followupDays]);

    console.log(`\n[Follow-ups] Found ${result.rows.length} bookings`);

    for (const booking of result.rows) {
      const templateId = booking.booking_type === 'open_day' ? 5 : 11; // Template IDs for follow-ups

      // Create scheduled_emails record
      await pool.query(
        `INSERT INTO scheduled_emails (booking_id, email_type, scheduled_for, template_id, status)
         VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4)
         ON CONFLICT (booking_id, email_type) DO NOTHING`,
        [booking.id, 'followup', templateId, 'pending']
      );

      await sendTemplateEmail(booking, templateId, 'followup');
    }
  } catch (error) {
    console.error('Error in sendFollowUpEmails:', error);
  }
}

// Send first reminder to tour guides (configurable days before)
async function sendGuideFirstReminders() {
  try {
    // Get reminder timing from settings
    const settingsResult = await pool.query(
      'SELECT guide_reminder_days_before_1 FROM booking_settings WHERE school_id = 2'
    );
    const reminderDays = settingsResult.rows[0]?.guide_reminder_days_before_1 || 3;

    console.log(`\n[Guide First Reminder] Checking for tours ${reminderDays} days from now`);

    // Find bookings with assigned guides for tours X days from now
    const result = await pool.query(`
      SELECT DISTINCT ON (b.id) b.*, e.title as event_title, e.event_date, e.start_time,
             tg.id as guide_id, tg.name as guide_name, tg.email as guide_email
      FROM bookings b
      LEFT JOIN events e ON b.event_id = e.id
      LEFT JOIN tour_guides tg ON b.assigned_guide_id = tg.id
      WHERE b.school_id = 2
        AND b.status = 'confirmed'
        AND b.assigned_guide_id IS NOT NULL
        AND (
          (e.event_date = CURRENT_DATE + INTERVAL '1 day' * $1 AND b.booking_type = 'open_day')
          OR (b.scheduled_date = CURRENT_DATE + INTERVAL '1 day' * $1 AND b.booking_type = 'private_tour')
        )
      ORDER BY b.id
    `, [reminderDays]);

    console.log(`\n[Guide First Reminder] Found ${result.rows.length} tours`);

    for (const booking of result.rows) {
      const guide = {
        id: booking.guide_id,
        name: booking.guide_name,
        email: booking.guide_email
      };

      await sendTourGuideNotification(booking, guide, 'reminder_first');
    }
  } catch (error) {
    console.error('Error in sendGuideFirstReminders:', error);
  }
}

// Send final reminder to tour guides (configurable days before)
async function sendGuideFinalReminders() {
  try {
    // Get reminder timing from settings
    const settingsResult = await pool.query(
      'SELECT guide_reminder_days_before_2 FROM booking_settings WHERE school_id = 2'
    );
    const reminderDays = settingsResult.rows[0]?.guide_reminder_days_before_2 || 1;

    console.log(`\n[Guide Final Reminder] Checking for tours ${reminderDays} day(s) from now`);

    // Find bookings with assigned guides for tours X days from now
    const result = await pool.query(`
      SELECT DISTINCT ON (b.id) b.*, e.title as event_title, e.event_date, e.start_time,
             tg.id as guide_id, tg.name as guide_name, tg.email as guide_email
      FROM bookings b
      LEFT JOIN events e ON b.event_id = e.id
      LEFT JOIN tour_guides tg ON b.assigned_guide_id = tg.id
      WHERE b.school_id = 2
        AND b.status = 'confirmed'
        AND b.assigned_guide_id IS NOT NULL
        AND (
          (e.event_date = CURRENT_DATE + INTERVAL '1 day' * $1 AND b.booking_type = 'open_day')
          OR (b.scheduled_date = CURRENT_DATE + INTERVAL '1 day' * $1 AND b.booking_type = 'private_tour')
        )
      ORDER BY b.id
    `, [reminderDays]);

    console.log(`\n[Guide Final Reminder] Found ${result.rows.length} tours`);

    for (const booking of result.rows) {
      const guide = {
        id: booking.guide_id,
        name: booking.guide_name,
        email: booking.guide_email
      };

      await sendTourGuideNotification(booking, guide, 'reminder_final');
    }
  } catch (error) {
    console.error('Error in sendGuideFinalReminders:', error);
  }
}

// Send no-show follow-up emails
async function sendNoShowFollowUps() {
  try {
    // Find bookings marked as no-show in the last 24 hours that haven't received a no-show email
    const result = await pool.query(`
      SELECT DISTINCT ON (b.id) b.*, e.title as event_title, e.event_date, e.start_time,
             tg.name as guide_name
      FROM bookings b
      LEFT JOIN events e ON b.event_id = e.id
      LEFT JOIN tour_guides tg ON b.assigned_guide_id = tg.id
      WHERE b.school_id = 2
        AND b.no_show_at IS NOT NULL
        AND b.no_show_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
        AND NOT EXISTS (
          SELECT 1 FROM scheduled_emails
          WHERE booking_id = b.id
          AND email_type = 'no_show_followup'
          AND status IN ('sent', 'pending')
        )
      ORDER BY b.id
    `);

    console.log(`\n[No-Show Follow-ups] Found ${result.rows.length} bookings`);

    for (const booking of result.rows) {
      // Template ID 12 for open days, 13 for private tours
      const templateId = booking.booking_type === 'open_day' ? 12 : 13;

      // Create scheduled_emails record
      await pool.query(
        `INSERT INTO scheduled_emails (booking_id, email_type, scheduled_for, template_id, status)
         VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4)
         ON CONFLICT (booking_id, email_type) DO NOTHING`,
        [booking.id, 'no_show_followup', templateId, 'pending']
      );

      await sendTemplateEmail(booking, templateId, 'no_show_followup');
    }
  } catch (error) {
    console.error('Error in sendNoShowFollowUps:', error);
  }
}

// Run email scheduler every hour
cron.schedule('0 * * * *', async () => {
  console.log('\n========================================');
  console.log(`Running automated email scheduler at ${new Date().toLocaleString()}`);
  console.log('========================================');

  await send7DayReminders();
  await send1DayReminders();
  await sendFollowUpEmails();
  await sendNoShowFollowUps();
  await sendGuideFirstReminders();
  await sendGuideFinalReminders();

  console.log('========================================\n');
});

// Run once on startup (for testing/immediate execution)
setTimeout(async () => {
  console.log('\n[Startup] Running initial email check...');
  await send7DayReminders();
  await send1DayReminders();
  await sendFollowUpEmails();
  await sendNoShowFollowUps();
  await sendGuideFirstReminders();
  await sendGuideFinalReminders();
}, 5000);

// Test email template
app.post('/api/email-templates/:id/test', async (req, res) => {
  try {
    const { id } = req.params;
    const { testEmail } = req.body;

    if (!testEmail) {
      return res.status(400).json({ success: false, error: 'testEmail is required' });
    }

    // Fetch template
    const template = await pool.query('SELECT * FROM email_templates WHERE id = $1', [id]);
    if (template.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Template not found' });
    }

    // Sample data for template variables
    const sampleData = {
      parent_name: 'Test Parent',
      student_name: 'Test Student',
      school_name: 'More House School',
      tour_date: '2025-12-15',
      tour_time: '10:00 AM',
      num_attendees: 3,
      tour_guide: 'John Smith',
      event_title: 'Sample Open Day Event',
      event_date: '2025-12-15',
      start_time: '10:00 AM'
    };

    // Replace template variables
    let subject = template.rows[0].subject;
    let body = template.rows[0].body;

    Object.keys(sampleData).forEach(key => {
      const regex = new RegExp(`{{${key}}}`, 'g');
      subject = subject.replace(regex, sampleData[key]);
      body = body.replace(regex, sampleData[key]);
    });

    // Send email
    await (await getEmailTransporter()).sendMail({
      from: process.env.GMAIL_USER,
      to: testEmail,
      subject: subject,
      text: body,
      html: body.replace(/\n/g, '<br>')
    });

    res.json({
      success: true,
      message: 'Test email sent successfully',
      templateName: template.rows[0].name,
      sentTo: testEmail
    });
  } catch (error) {
    console.error('Test email error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`Booking server running on http://localhost:${PORT}`);
});
